{"ast":null,"code":"/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, base58check as _b58, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nconst {\n  ProjectivePoint: ProjPoint,\n  sign: _signECDSA,\n  getPublicKey: _pubECDSA\n} = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => value === undefined ? def : value;\nconst isBytes = P.isBytes;\nconst hash160 = msg => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = _b58(sha256);\nexport function cloneDeep(obj) {\n  if (Array.isArray(obj)) return obj.map(i => cloneDeep(i));\n  // slice of nodejs Buffer doesn't copy\n  else if (obj instanceof Uint8Array) return Uint8Array.from(obj);\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n  }\n  throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\nvar PubT;\n(function (PubT) {\n  PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n  PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n  const len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    ProjPoint.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\nfunction isValidPubkey(pub, type) {\n  try {\n    validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = sig => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n  let sig = _signECDSA(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    const extraEntropy = new Uint8Array(32);\n    for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n      extraEntropy.set(P.U32LE.encode(cnt));\n      sig = _signECDSA(hash, privateKey, {\n        extraEntropy\n      });\n      if (hasLowR(sig)) break;\n    }\n  }\n  return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n  const u = schnorr.utils;\n  const t = u.taggedHash('TapTweak', a, b);\n  const tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\nexport function taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n  const u = schnorr.utils;\n  const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  const xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  const t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n  const u = schnorr.utils;\n  const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), pub => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), pub => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), sig => {\n  if (sig.length !== 64 && sig.length !== 65) throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\nfunction uniqPubkey(pubkeys) {\n  const map = {};\n  for (const pub of pubkeys) {\n    const key = hex.encode(pub);\n    if (map[key]) throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n    map[key] = true;\n  }\n}\nexport const NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nexport const TEST_NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef\n};\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n  OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n  OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n  OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n  OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n  OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n  OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n  OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n  OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n  OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n  OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n  OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n  OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n  OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n  OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n  OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n  OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n  OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n  OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n  OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n  OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n  OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n  OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n  // Control\n  OP[OP[\"NOP\"] = 97] = \"NOP\";\n  OP[OP[\"VER\"] = 98] = \"VER\";\n  OP[OP[\"IF\"] = 99] = \"IF\";\n  OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n  OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n  OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n  OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n  OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n  OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n  OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n  // Stack\n  OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n  OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n  OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n  OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n  OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n  OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n  OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n  OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n  OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n  OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n  OP[OP[\"DROP\"] = 117] = \"DROP\";\n  OP[OP[\"DUP\"] = 118] = \"DUP\";\n  OP[OP[\"NIP\"] = 119] = \"NIP\";\n  OP[OP[\"OVER\"] = 120] = \"OVER\";\n  OP[OP[\"PICK\"] = 121] = \"PICK\";\n  OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n  OP[OP[\"ROT\"] = 123] = \"ROT\";\n  OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n  OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n  // Splice\n  OP[OP[\"CAT\"] = 126] = \"CAT\";\n  OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n  OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n  OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n  OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n  // Boolean logic\n  OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n  OP[OP[\"AND\"] = 132] = \"AND\";\n  OP[OP[\"OR\"] = 133] = \"OR\";\n  OP[OP[\"XOR\"] = 134] = \"XOR\";\n  OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n  OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n  OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n  OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n  // Numbers\n  OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n  OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n  OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n  OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n  OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n  OP[OP[\"ABS\"] = 144] = \"ABS\";\n  OP[OP[\"NOT\"] = 145] = \"NOT\";\n  OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n  OP[OP[\"ADD\"] = 147] = \"ADD\";\n  OP[OP[\"SUB\"] = 148] = \"SUB\";\n  OP[OP[\"MUL\"] = 149] = \"MUL\";\n  OP[OP[\"DIV\"] = 150] = \"DIV\";\n  OP[OP[\"MOD\"] = 151] = \"MOD\";\n  OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n  OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n  OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n  OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n  OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n  OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n  OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n  OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n  OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n  OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n  OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n  OP[OP[\"MIN\"] = 163] = \"MIN\";\n  OP[OP[\"MAX\"] = 164] = \"MAX\";\n  OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n  // Crypto\n  OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n  OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n  OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n  OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n  OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n  OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n  OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n  OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n  OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n  OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n  // Expansion\n  OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n  OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n  OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n  OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n  OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n  OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n  OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n  OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n  OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n  OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n  // BIP 342\n  OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n  // Invalid\n  OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script = P.wrap({\n  encodeStream: (w, value) => {\n    for (let o of value) {\n      if (typeof o === 'string') {\n        if (OP[o] === undefined) throw new Error(`Unknown opcode=${o}`);\n        w.byte(OP[o]);\n        continue;\n      } else if (typeof o === 'number') {\n        if (o === 0x00) {\n          w.byte(0x00);\n          continue;\n        } else if (1 <= o && o <= 16) {\n          w.byte(OP.OP_1 - 1 + o);\n          continue;\n        }\n      }\n      // Encode big numbers\n      if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n      if (!isBytes(o)) throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n      // Bytes\n      const len = o.length;\n      if (len < OP.PUSHDATA1) w.byte(len);else if (len <= 0xff) {\n        w.byte(OP.PUSHDATA1);\n        w.byte(len);\n      } else if (len <= 0xffff) {\n        w.byte(OP.PUSHDATA2);\n        w.bytes(P.U16LE.encode(len));\n      } else {\n        w.byte(OP.PUSHDATA4);\n        w.bytes(P.U32LE.encode(len));\n      }\n      w.bytes(o);\n    }\n  },\n  decodeStream: r => {\n    const out = [];\n    while (!r.isEnd()) {\n      const cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        let len;\n        if (cur < OP.PUSHDATA1) len = cur;else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        const op = OP[cur];\n        if (op === undefined) throw new Error(`Unknown opcode=${cur.toString(16)}`);\n        out.push(op);\n      }\n    }\n    return out;\n  }\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false) {\n  return P.wrap({\n    encodeStream: (w, value) => {\n      if (value === 0n) return;\n      const neg = value < 0;\n      const val = BigInt(value);\n      const nums = [];\n      for (let abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: r => {\n      const len = r.leftBytes;\n      if (len > bytesLimit) throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((r.data[len - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (r.data[len - 2] & 0x80) === 0) throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      let last = 0;\n      let res = 0n;\n      for (let i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << 8n * BigInt(i);\n      }\n      if (last >= 0x80) {\n        res &= 2n ** BigInt(len * 8) - 1n >> 1n;\n        res = -res;\n      }\n      return res;\n    }\n  });\n}\nexport function OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n]\n};\nexport const CompactSize = P.wrap({\n  encodeStream: (w, value) => {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (let i = 0; i < bytes; i++) w.byte(Number(value >> 8n * BigInt(i) & 0xffn));\n      return;\n    }\n    throw w.err(`VarInt too big: ${value}`);\n  },\n  decodeStream: r => {\n    const b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    const [_, bytes, start] = CSLimits[b0];\n    let num = 0n;\n    for (let i = 0; i < bytes; i++) num |= BigInt(r.byte()) << 8n * BigInt(i);\n    if (num < start) throw r.err(`Wrong CompactSize(${8 * bytes})`);\n    return num;\n  }\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport const BTCArray = t => P.array(CompactSize, t);\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\nexport const RawInput = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE,\n  finalScriptSig: VarBytes,\n  sequence: P.U32LE // ?\n});\n\nexport const RawOutput = P.struct({\n  amount: P.U64LE,\n  script: VarBytes\n});\nconst EMPTY_OUTPUT = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY\n};\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE\n});\nfunction validateRawTx(tx) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length) throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n  const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n  return {\n    type,\n    kc,\n    vc,\n    reqInc,\n    allowInc,\n    silentIgnore\n  };\n}\nconst BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE)\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n  version: P.U8,\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32))\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, cb => {\n  if (cb.merklePath.length > 128) throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\nconst TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({\n  pubKey: PubKeySchnorr,\n  leafHash: P.bytes(32)\n});\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n  depth: P.U8,\n  version: P.U8,\n  script: VarBytes\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n  unsignedTx: [0x00, false, RawTx, [0], [0], false],\n  xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n  txVersion: [0x02, false, P.U32LE, [2], [2], false],\n  fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n  inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n  outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n  txModifiable: [0x06, false, P.U8, [], [2], false],\n  version: [0xfb, false, P.U32LE, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// prettier-ignore\nconst PSBTInput = {\n  nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n  witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n  partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n  sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n  redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n  finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n  porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n  ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n  sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n  hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n  hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n  txid: [0x0e, false, Bytes32, [2], [2], true],\n  index: [0x0f, false, P.U32LE, [2], [2], true],\n  sequence: [0x10, false, P.U32LE, [], [2], true],\n  requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n  requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n  tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n  tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n  tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n  tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n  tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n  tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys = ['txid', 'sequence', 'index', 'witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknown'];\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys = ['partialSig', 'finalScriptSig', 'finalScriptWitness', 'tapKeySig', 'tapScriptSig'];\n// prettier-ignore\nconst PSBTOutput = {\n  redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n  witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n  bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n  amount: [0x03, false, P.I64LE, [2], [2], true],\n  script: [0x04, false, BytesInf, [2], [2], true],\n  tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n  tapTree: [0x06, false, tapTree, [], [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n  proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false]\n};\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n  //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n  key: P.prefix(CompactSizeLen, P.struct({\n    type: CompactSizeLen,\n    key: P.bytes(null)\n  })),\n  //  <value> := <valuelen> <valuedata>\n  value: P.bytes(CompactSizeLen)\n}));\nconst PSBTUnknownKey = P.struct({\n  type: CompactSizeLen,\n  key: P.bytes(null)\n});\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n  // -> Record<type, [keyName, ...coders]>\n  const byType = {};\n  for (const k in psbtEnum) {\n    const [num, kc, vc] = psbtEnum[k];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: (w, value) => {\n      let out = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      for (const name in psbtEnum) {\n        const val = value[name];\n        if (val === undefined) continue;\n        const [type, kc, vc] = psbtEnum[name];\n        if (!kc) {\n          out.push({\n            key: {\n              type,\n              key: P.EMPTY\n            },\n            value: vc.encode(val)\n          });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          const kv = val.map(([k, v]) => [kc.encode(k), vc.encode(v)]);\n          // sort by keys\n          kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n          for (const [key, value] of kv) out.push({\n            key: {\n              key,\n              type\n            },\n            value\n          });\n        }\n      }\n      if (value.unknown) {\n        value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n        for (const [k, v] of value.unknown) out.push({\n          key: k,\n          value: v\n        });\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: r => {\n      const raw = PSBTKeyPair.decodeStream(r);\n      const out = {};\n      const noKey = {};\n      for (const elm of raw) {\n        let name = 'unknown';\n        let key = elm.key.key;\n        let value = elm.value;\n        if (byType[elm.key.type]) {\n          const [_name, kc, vc] = byType[elm.key.type];\n          name = _name;\n          if (!kc && key.length) {\n            throw new Error(`PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`);\n          }\n          key = kc ? kc.decode(key) : undefined;\n          value = vc.decode(value);\n          if (!kc) {\n            if (out[name]) throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n            out[name] = value;\n            noKey[name] = true;\n            continue;\n          }\n        } else {\n          // For unknown: add key type inside key\n          key = {\n            type: elm.key.type,\n            key: elm.key.key\n          };\n        }\n        // Only keyed elements at this point\n        if (noKey[name]) throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n        if (!out[name]) out[name] = [];\n        out[name].push([key, value]);\n      }\n      return out;\n    }\n  });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n  if (!P.equalBytes(s.hash, sha256(witnessScript))) throw new Error('checkScript: wsh wrong witnessScript hash');\n  const w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms') throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n  if (w.type === 'wpkh' || w.type === 'sh') throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n  if (script) {\n    const s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk') throw new Error(`checkScript: non-wrapped ${s.type}`);\n    if (s.type === 'sh' && redeemScript) {\n      if (!P.equalBytes(s.hash, hash160(redeemScript))) throw new Error('checkScript: sh wrong redeemScript hash');\n      const r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms') throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    const r = OutScript.decode(redeemScript);\n    if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);\n  }\n}\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), i => {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length) throw new Error('validateInput: wmpty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) for (const [k] of i.partialSig) validatePubkey(k, PubT.ecdsa);\n  if (i.bip32Derivation) for (const [k] of i.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000) throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (i.requiredHeightLocktime !== undefined && (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)) throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    const last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n    const prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (i.witnessUtxo && (!P.equalBytes(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)) throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n  }\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    for (const [k, v] of i.tapLeafScript) {\n      if ((k.version & 254) !== v[v.length - 1]) throw new Error('validateInput: tapLeafScript version mimatch');\n      if (v[v.length - 1] & 1) throw new Error('validateInput: tapLeafScript version has parity bit!');\n    }\n  }\n  // Validate txid for nonWitnessUtxo is correct\n  if (i.nonWitnessUtxo && i.index && i.txid) {\n    const outputs = i.nonWitnessUtxo.outputs;\n    if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n    const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo));\n    const txid = hex.encode(i.txid);\n    if (tx.id !== txid) throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n  }\n  return i;\n});\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), o => {\n  if (o.bip32Derivation) for (const [k] of o.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), g => {\n  const version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses) throw new Error('PSBTv0: witness in unsingedTx');\n    for (const inp of g.unsignedTx.inputs) if (inp.finalScriptSig && inp.finalScriptSig.length) throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n  }\n  return g;\n});\nexport const _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder)\n});\nexport const _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder)\n});\nexport const _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict()))\n});\nfunction validatePSBTFields(version, info, lst) {\n  for (const k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    const {\n      allowInc\n    } = PSBTKeyInfo(info[k]);\n    if (!allowInc.includes(version)) throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n  }\n  for (const k in info) {\n    const {\n      reqInc\n    } = PSBTKeyInfo(info[k]);\n    if (reqInc.includes(version) && lst[k] === undefined) throw new Error(`PSBTv${version}: missing required field ${k}`);\n  }\n}\nfunction cleanPSBTFields(version, info, lst) {\n  const out = {};\n  for (const _k in lst) {\n    const k = _k;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      const {\n        allowInc,\n        silentIgnore\n      } = PSBTKeyInfo(info[k]);\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\nfunction validatePSBT(tx) {\n  const version = tx && tx.global && tx.global.version || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  for (const i of tx.inputs) validatePSBTFields(version, PSBTInput, i);\n  for (const o of tx.outputs) validatePSBTFields(version, PSBTOutput, o);\n  // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  const inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || inputsLeft.length && Object.keys(inputsLeft[0]).length) throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n  // Same for inputs\n  const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  const outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || outputsLeft.length && Object.keys(outputsLeft[0]).length) throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n  return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n  const res = {\n    ...cur,\n    ...val\n  };\n  // All arguments can be provided as hex\n  for (const k in psbtEnum) {\n    const key = k;\n    const [_, kC, vC] = psbtEnum[key];\n    const cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(`Cannot remove signed field=${k}`);\n      delete res[k];\n    } else if (kC) {\n      const oldKV = cur && cur[k] ? cur[k] : [];\n      let newKV = val[key];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n        // Decode hex in k-v\n        newKV = newKV.map(val => {\n          if (val.length !== 2) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n          return [typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0], typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1]];\n        });\n        const map = {};\n        const add = (kStr, k, v) => {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          const oldVal = hex.encode(vC.encode(map[kStr][1]));\n          const newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal) throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n        };\n        for (const [k, v] of oldKV) {\n          const kStr = hex.encode(kC.encode(k));\n          add(kStr, k, v);\n        }\n        for (const [k, v] of newKV) {\n          const kStr = hex.encode(kC.encode(k));\n          // undefined removes previous value\n          if (v === undefined) {\n            if (cannotChange) throw new Error(`Cannot remove signed field=${key}/${k}`);\n            delete map[kStr];\n          } else add(kStr, k, v);\n        }\n        res[key] = Object.values(map);\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k]));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k]))) throw new Error(`Cannot change signed field=${k}`);\n    }\n  }\n  // Remove unknown keys\n  for (const k in res) if (!psbtEnum[k]) delete res[k];\n  return res;\n}\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({\n  txid: P.bytes(32, true),\n  index: P.U32LE\n});\nconst OutPK = {\n  encode(from) {\n    if (from.length !== 2 || !isBytes(from[0]) || !isValidPubkey(from[0], PubT.ecdsa) || from[1] !== 'CHECKSIG') return;\n    return {\n      type: 'pk',\n      pubkey: from[0]\n    };\n  },\n  decode: to => to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined\n};\n// @ts-ignore\nexport const p2pk = (pubkey, network = NETWORK) => {\n  // network is unused\n  if (!isValidPubkey(pubkey, PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return {\n    type: 'pk',\n    script: OutScript.encode({\n      type: 'pk',\n      pubkey\n    })\n  };\n};\nconst OutPKH = {\n  encode(from) {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2])) return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return {\n      type: 'pkh',\n      hash: from[2]\n    };\n  },\n  decode: to => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined\n};\nexport const p2pkh = (publicKey, network = NETWORK) => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  const hash = hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({\n      type: 'pkh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'pkh',\n      hash\n    })\n  };\n};\nconst OutSH = {\n  encode(from) {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL') return;\n    return {\n      type: 'sh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined\n};\nexport const p2sh = (child, network = NETWORK) => {\n  // It is already tested inside noble-hashes and checkScript\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n  const hash = hash160(cs);\n  const script = OutScript.encode({\n    type: 'sh',\n    hash\n  });\n  checkScript(script, cs, child.witnessScript);\n  const res = {\n    type: 'sh',\n    redeemScript: cs,\n    script: OutScript.encode({\n      type: 'sh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'sh',\n      hash\n    })\n  };\n  if (child.witnessScript) res.witnessScript = child.witnessScript;\n  return res;\n};\nconst OutWSH = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return {\n      type: 'wsh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'wsh' ? [0, to.hash] : undefined\n};\nexport const p2wsh = (child, network = NETWORK) => {\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n  const hash = sha256(cs);\n  const script = OutScript.encode({\n    type: 'wsh',\n    hash\n  });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({\n      type: 'wsh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'wsh',\n      hash\n    })\n  };\n};\nconst OutWPKH = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return {\n      type: 'wpkh',\n      hash: from[1]\n    };\n  },\n  decode: to => to.type === 'wpkh' ? [0, to.hash] : undefined\n};\nexport const p2wpkh = (publicKey, network = NETWORK) => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  const hash = hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({\n      type: 'wpkh',\n      hash\n    }),\n    address: Address(network).encode({\n      type: 'wpkh',\n      hash\n    })\n  };\n};\nconst OutMS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    const m = from[0];\n    const n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    const pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    for (const pub of pubkeys) if (!isBytes(pub)) return;\n    return {\n      type: 'ms',\n      m,\n      pubkeys: pubkeys\n    }; // we don't need n, since it is the same as pubkeys\n  },\n\n  // checkmultisig(n, ..pubkeys, m)\n  decode: to => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined\n};\nexport const p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'ms',\n    script: OutScript.encode({\n      type: 'ms',\n      pubkeys,\n      m\n    })\n  };\n};\nconst OutTR = {\n  encode(from) {\n    if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1])) return;\n    return {\n      type: 'tr',\n      pubkey: from[1]\n    };\n  },\n  decode: to => to.type === 'tr' ? [1, to.pubkey] : undefined\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n  // Clone input in order to not corrupt it\n  const lst = Array.from(taprootList);\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n    const b = lst.pop();\n    const a = lst.pop();\n    const weight = (a?.weight || 1) + (b?.weight || 1);\n    lst.push({\n      weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [a?.childs || a, b?.childs || b]\n    });\n  }\n  // At this point there is always 1 element in lst\n  const last = lst[0];\n  return last?.childs || last;\n}\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false) {\n  const out = OutScript.decode(script);\n  if (out.type === 'unknown' && allowUnknownOutputs) return;\n  if (!['tr_ns', 'tr_ms'].includes(out.type)) throw new Error(`P2TR: invalid leaf script=${out.type}`);\n  const outms = out;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    for (const p of outms.pubkeys) {\n      if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY)) throw new Error('Unspendable taproot key in leaf script');\n      // It's likely a mistake at this point:\n      // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n      // but will take more space and fees.\n      // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n      // User creates 2 of 3 multisig of keys [A, B, C],\n      // but key A always can spend whole output without signatures from other keys.\n      // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n      if (P.equalBytes(p, internalPubKey)) {\n        throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n      }\n    }\n  }\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false) {\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    const {\n      leafVersion: version,\n      script: leafScript\n    } = tree;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)) throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!isBytes(script)) throw new Error(`checkScript: wrong script type=${script}`);\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n    return {\n      type: 'leaf',\n      version,\n      script,\n      hash: tapLeafHash(script, version)\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree);\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n  const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n  // We cannot swap left/right here, since it will change structure of tree\n  let [lH, rH] = [left.hash, right.hash];\n  if (_cmpBytes(rH, lH) === -1) [lH, rH] = [rH, lH];\n  return {\n    type: 'branch',\n    left,\n    right,\n    hash: schnorr.utils.taggedHash('TapBranch', lH, rH)\n  };\n}\nfunction taprootAddPath(tree, path = []) {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return {\n    ...tree,\n    path\n  };\n  if (tree.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${tree}`);\n  return {\n    ...tree,\n    path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n    right: taprootAddPath(tree.right, [tree.left.hash, ...path])\n  };\n}\nfunction taprootWalkTree(tree) {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${tree}`);\n  return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree, network = NETWORK, allowUnknownOutputs = false) {\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  const pubKey = typeof internalPubKey === 'string' ? hex.decode(internalPubKey) : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  let hashedTree = tree ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs)) : undefined;\n  const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n  const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n  let leaves;\n  if (hashedTree) {\n    leaves = taprootWalkTree(hashedTree).map(l => ({\n      ...l,\n      controlBlock: TaprootControlBlock.encode({\n        version: (l.version || TAP_LEAF_VERSION) + parity,\n        internalKey: pubKey,\n        merklePath: l.path\n      })\n    }));\n  }\n  let tapLeafScript;\n  if (leaves) {\n    tapLeafScript = leaves.map(l => [TaprootControlBlock.decode(l.controlBlock), concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION]))]);\n  }\n  const res = {\n    type: 'tr',\n    script: OutScript.encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    address: Address(network).encode({\n      type: 'tr',\n      pubkey: tweakedPubkey\n    }),\n    // For tests\n    tweakedPubkey,\n    // PSBT stuff\n    tapInternalKey: pubKey\n  };\n  // Just in case someone would want to select a specific script\n  if (leaves) res.leaves = leaves;\n  if (tapLeafScript) res.tapLeafScript = tapLeafScript;\n  if (tapMerkleRoot) res.tapMerkleRoot = tapMerkleRoot;\n  return res;\n}\nconst OutTRNS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    // On error return, since it can be different script\n    for (let i = 0; i < last; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ns',\n      pubkeys\n    };\n  },\n  decode: to => {\n    if (to.type !== 'tr_ns') return;\n    const out = [];\n    for (let i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  }\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n  const res = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  const n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  const idx = Array.from({\n    length: m\n  }, (_, i) => i);\n  const last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map(i => list[i]));\n    idx[last] += 1;\n    let i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map(i => ({\n    type: 'tr_ns',\n    script: OutScript.encode({\n      type: 'tr_ns',\n      pubkeys: i\n    })\n  }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = pubkey => p2tr_ns(1, [pubkey], undefined)[0];\nconst OutTRMS = {\n  encode(from) {\n    const last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    const m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (let i = 0; i < last - 1; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD')) throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return {\n      type: 'tr_ms',\n      pubkeys,\n      m\n    };\n  },\n  decode: to => {\n    if (to.type !== 'tr_ms') return;\n    const out = [to.pubkeys[0], 'CHECKSIG'];\n    for (let i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  }\n};\nexport function p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({\n      type: 'tr_ms',\n      pubkeys,\n      m\n    })\n  };\n}\nconst OutUnknown = {\n  encode(from) {\n    return {\n      type: 'unknown',\n      script: Script.encode(from)\n    };\n  },\n  decode: to => to.type === 'unknown' ? Script.decode(to.script) : undefined\n};\n// /Payments\nconst OutScripts = [OutPK, OutPKH, OutSH, OutWSH, OutWPKH, OutMS, OutTR, OutTRNS, OutTRMS, OutUnknown];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, i => {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa)) throw new Error('OutScript/pk: wrong key');\n  if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') && (!isBytes(i.hash) || i.hash.length !== 20)) throw new Error(`OutScript/${i.type}: wrong hash`);\n  if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32)) throw new Error(`OutScript/wsh: wrong hash`);\n  if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr))) throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms') if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    const n = i.pubkeys.length;\n    for (const p of i.pubkeys) if (!isValidPubkey(p, PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    for (const p of i.pubkeys) if (!isValidPubkey(p, PubT.schnorr)) throw new Error(`OutScript/${i.type}: wrong pubkey`);\n  }\n  if (i.type === 'tr_ms') {\n    const n = i.pubkeys.length;\n    if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\n// Address\nfunction validateWitness(version, data) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32)) throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data, network = NETWORK) {\n  validateWitness(version, data);\n  const coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n  return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF(network = NETWORK) {\n  return {\n    encode(privKey) {\n      const compressed = concat(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode(wif) {\n      let parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    }\n  };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n  return {\n    encode(from) {\n      const {\n        type\n      } = from;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);else if (type === 'wsh') return programToWitness(0, from.hash, network);else if (type === 'tr') return programToWitness(1, from.pubkey, network);else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(`Unknown address type=${type}`);\n    },\n    decode(address) {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n        let res;\n        try {\n          res = bech32.decode(address);\n          if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`);\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address);\n          if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`);\n        }\n        if (res.prefix !== network.bech32) throw new Error(`wrong bech32 prefix=${res.prefix}`);\n        const [version, ...program] = res.words;\n        const data = bech32.fromWords(program);\n        validateWitness(version, data);\n        if (version === 0 && data.length === 32) return {\n          type: 'wsh',\n          hash: data\n        };else if (version === 0 && data.length === 20) return {\n          type: 'wpkh',\n          hash: data\n        };else if (version === 1 && data.length === 32) return {\n          type: 'tr',\n          pubkey: data\n        };else throw new Error('Unknown witness program');\n      }\n      const data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return {\n          type: 'pkh',\n          hash: data.slice(1)\n        };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1)\n        };\n      }\n      throw new Error(`Invalid address prefix=${data[0]}`);\n    }\n  };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n  SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n  SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n  SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n  SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n  SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n  SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n  SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n  SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n  SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n  SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string') throw new Error(`Invalid SigHash=${s}`);\n  return s;\n}\nfunction unpackSighash(hashType) {\n  const masked = hashType & 0b0011111;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE\n  };\n}\nexport const _sortPubkeys = pubkeys => Array.from(pubkeys).sort(_cmpBytes);\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n  if (i.txid === undefined || i.index === undefined) throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY)\n  };\n}\nfunction cleanFinalInput(i) {\n  for (const _k in i) {\n    const k = _k;\n    if (!PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n  if (i.script === undefined || i.amount === undefined) throw new Error('Transaction/output: script and amount required');\n  return {\n    script: i.script,\n    amount: i.amount\n  };\n}\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script, version = TAP_LEAF_VERSION) => schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n  if (P.equalBytes(internalKey, pubKey)) {\n    privKey = taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = schnorr.getPublicKey(privKey);\n  }\n  return {\n    privKey,\n    pubKey\n  };\n}\nconst toStr = {}.toString;\nfunction validateOpts(opts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error(`Wrong object type for transaction options: ${opts}`);\n  const _opts = {\n    ...opts,\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0)\n  };\n  if (typeof _opts.allowUnknowInput !== 'undefined') opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined') opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  // 0 and -1 happens in tests\n  if (![-1, 0, 1, 2].includes(_opts.version)) throw new Error(`Unknown version: ${_opts.version}`);\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n  // Flags\n  for (const k of ['allowUnknownOutputs', 'allowUnknownInputs', 'disableScriptCheck', 'bip174jsCompat', 'allowLegacyWitnessUtxo', 'lowR']) {\n    const v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean') throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n  }\n  return Object.freeze(_opts);\n}\nexport class Transaction {\n  constructor(opts = {}) {\n    this.global = {};\n    this.inputs = []; // use getInput()\n    this.outputs = []; // use getOutput()\n    const _opts = this.opts = validateOpts(opts);\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n  // Import\n  static fromRaw(raw, opts = {}) {\n    const parsed = RawTx.decode(raw);\n    const tx = new Transaction({\n      ...opts,\n      version: parsed.version,\n      lockTime: parsed.lockTime\n    });\n    for (const o of parsed.outputs) tx.addOutput(o);\n    tx.outputs = parsed.outputs;\n    tx.inputs = parsed.inputs;\n    if (parsed.witnesses) {\n      for (let i = 0; i < parsed.witnesses.length; i++) tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n    }\n    return tx;\n  }\n  // PSBT\n  static fromPSBT(psbt, opts = {}) {\n    let parsed;\n    try {\n      parsed = RawPSBTV0.decode(psbt);\n    } catch (e0) {\n      try {\n        parsed = RawPSBTV2.decode(psbt);\n      } catch (e2) {\n        // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n        throw e0;\n      }\n    }\n    const PSBTVersion = parsed.global.version || 0;\n    if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const unsigned = parsed.global.unsignedTx;\n    const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n    const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n    const tx = new Transaction({\n      ...opts,\n      version,\n      lockTime,\n      PSBTVersion\n    });\n    // We need slice here, because otherwise\n    const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n    tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n      finalScriptSig: P.EMPTY,\n      ...parsed.global.unsignedTx?.inputs[j],\n      ...i\n    }));\n    const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n    tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n      ...i,\n      ...parsed.global.unsignedTx?.outputs[j]\n    }));\n    tx.global = {\n      ...parsed.global,\n      txVersion: version\n    }; // just in case proprietary/unknown fields\n    if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n    return tx;\n  }\n  toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n    if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const inputs = this.inputs.map(i => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n    for (const inp of inputs) {\n      // Don't serialize empty fields\n      if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n      if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n      if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n    }\n    const outputs = this.outputs.map(i => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n    const global = {\n      ...this.global\n    };\n    if (PSBTVersion === 0) {\n      global.unsignedTx = RawTx.decode(this.unsignedTx);\n      delete global.fallbackLocktime;\n      delete global.txVersion;\n    } else {\n      global.version = PSBTVersion;\n      global.txVersion = this.version;\n      global.inputCount = this.inputs.length;\n      global.outputCount = this.outputs.length;\n      if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME) delete global.fallbackLocktime;\n    }\n    if (this.opts.bip174jsCompat) {\n      if (!inputs.length) inputs.push({});\n      if (!outputs.length) outputs.push({});\n    }\n    return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n      global,\n      inputs,\n      outputs\n    });\n  }\n  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  get lockTime() {\n    let height = DEFAULT_LOCKTIME;\n    let heightCnt = 0;\n    let time = DEFAULT_LOCKTIME;\n    let timeCnt = 0;\n    for (const i of this.inputs) {\n      if (i.requiredHeightLocktime) {\n        height = Math.max(height, i.requiredHeightLocktime);\n        heightCnt++;\n      }\n      if (i.requiredTimeLocktime) {\n        time = Math.max(time, i.requiredTimeLocktime);\n        timeCnt++;\n      }\n    }\n    if (heightCnt && heightCnt >= timeCnt) return height;\n    if (time !== DEFAULT_LOCKTIME) return time;\n    return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n  }\n  get version() {\n    // Should be not possible\n    if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n    return this.global.txVersion;\n  }\n  inputStatus(idx) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    // Finalized\n    if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n    if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n    // Signed taproot\n    if (input.tapKeySig) return 'signed';\n    if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n    // Signed\n    if (input.partialSig && input.partialSig.length) return 'signed';\n    return 'unsigned';\n  }\n  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n  // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  inputSighash(idx) {\n    this.checkInputIdx(idx);\n    const sighash = this.inputType(this.inputs[idx]).sighash;\n    // ALL or DEFAULT -- everything signed\n    // NONE           -- all inputs + no outputs\n    // SINGLE         -- all inputs + output with same index\n    // ALL + ANYONE   -- specific input + all outputs\n    // NONE + ANYONE  -- specific input + no outputs\n    // SINGLE         -- specific inputs + output with same index\n    const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n    const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n    return {\n      sigInputs,\n      sigOutputs\n    };\n  }\n  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n  // Some cache will be nice, but there chance to have bugs with cache invalidation\n  signStatus() {\n    // if addInput or addOutput is not possible, then all inputs or outputs are signed\n    let addInput = true,\n      addOutput = true;\n    let inputs = [],\n      outputs = [];\n    for (let idx = 0; idx < this.inputs.length; idx++) {\n      const status = this.inputStatus(idx);\n      // Unsigned input doesn't affect anything\n      if (status === 'unsigned') continue;\n      const {\n        sigInputs,\n        sigOutputs\n      } = this.inputSighash(idx);\n      // Input type\n      if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);else addInput = false;\n      // Output type\n      if (sigOutputs === SignatureHash.ALL) addOutput = false;else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);else if (sigOutputs === SignatureHash.NONE) {\n        // Doesn't affect any outputs at all\n      } else throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n    }\n    return {\n      addInput,\n      addOutput,\n      inputs,\n      outputs\n    };\n  }\n  get isFinal() {\n    for (let idx = 0; idx < this.inputs.length; idx++) if (this.inputStatus(idx) !== 'finalized') return false;\n    return true;\n  }\n  // Info utils\n  get hasWitnesses() {\n    let out = false;\n    for (const i of this.inputs) if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n    return out;\n  }\n  // https://en.bitcoin.it/wiki/Weight_units\n  get weight() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    // TODO: Can we find out how much witnesses/script will be used before signing?\n    let out = 32;\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (this.hasWitnesses) out += 2;\n    out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n    out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n    for (const i of this.inputs) out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n    for (const o of outputs) out += 32 + 4 * VarBytes.encode(o.script).length;\n    if (this.hasWitnesses) {\n      for (const i of this.inputs) if (i.finalScriptWitness) out += RawWitness.encode(i.finalScriptWitness).length;\n    }\n    return out;\n  }\n  get vsize() {\n    return Math.ceil(this.weight / 4);\n  }\n  toBytes(withScriptSig = false, withWitness = false) {\n    return RawTx.encode({\n      version: this.version,\n      lockTime: this.lockTime,\n      inputs: this.inputs.map(inputBeforeSign).map(i => ({\n        ...i,\n        finalScriptSig: withScriptSig && i.finalScriptSig || P.EMPTY\n      })),\n      outputs: this.outputs.map(outputBeforeSign),\n      witnesses: this.inputs.map(i => i.finalScriptWitness || []),\n      segwitFlag: withWitness && this.hasWitnesses\n    });\n  }\n  get unsignedTx() {\n    return this.toBytes(false, false);\n  }\n  get hex() {\n    return hex.encode(this.toBytes(true, this.hasWitnesses));\n  }\n  get hash() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)));\n  }\n  get id() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)).reverse());\n  }\n  // Input stuff\n  checkInputIdx(idx) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length) throw new Error(`Wrong input index=${idx}`);\n  }\n  getInput(idx) {\n    this.checkInputIdx(idx);\n    return cloneDeep(this.inputs[idx]);\n  }\n  get inputsLength() {\n    return this.inputs.length;\n  }\n  // Modification\n  normalizeInput(i, cur, allowedFields) {\n    let {\n      nonWitnessUtxo,\n      txid\n    } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors (like hex looking string accidentally passed),\n    // however in case of nonWitnessUtxo it is better to expect string, since constructing this complex object will be difficult for user\n    if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n    if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n    if (nonWitnessUtxo === undefined) nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string') txid = hex.decode(txid);\n    if (txid === undefined) txid = cur?.txid;\n    let res = {\n      ...cur,\n      ...i,\n      nonWitnessUtxo,\n      txid\n    };\n    if (res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n    if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n    res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n    PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined) prevOut = res.nonWitnessUtxo.outputs[res.index];else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n    if (prevOut && !this.opts.disableScriptCheck) checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addInput(input, _ignoreSignStatus = false) {\n    if (!_ignoreSignStatus && !this.signStatus().addInput) throw new Error('Tx has signed inputs, cannot add new one');\n    this.inputs.push(this.normalizeInput(input));\n    return this.inputs.length - 1;\n  }\n  updateInput(idx, input, _ignoreSignStatus = false) {\n    this.checkInputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addInput || status.inputs.includes(idx)) allowedFields = PSBTInputUnsignedKeys;\n    }\n    this.inputs[idx] = this.normalizeInput(input, this.inputs[idx], allowedFields);\n  }\n  // Output stuff\n  checkOutputIdx(idx) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length) throw new Error(`Wrong output index=${idx}`);\n  }\n  getOutput(idx) {\n    this.checkOutputIdx(idx);\n    return cloneDeep(this.outputs[idx]);\n  }\n  get outputsLength() {\n    return this.outputs.length;\n  }\n  normalizeOutput(o, cur, allowedFields) {\n    let {\n      amount,\n      script\n    } = o;\n    if (amount === undefined) amount = cur?.amount;\n    if (typeof amount !== 'bigint') throw new Error('amount must be bigint sats');\n    if (typeof script === 'string') script = hex.decode(script);\n    if (script === undefined) script = cur?.script;\n    let res = {\n      ...cur,\n      ...o,\n      amount,\n      script\n    };\n    if (res.amount === undefined) delete res.amount;\n    res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n    PSBTOutputCoder.encode(res);\n    if (res.script && !this.opts.allowUnknownOutputs && OutScript.decode(res.script).type === 'unknown') {\n      throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure');\n    }\n    if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addOutput(o, _ignoreSignStatus = false) {\n    if (!_ignoreSignStatus && !this.signStatus().addOutput) throw new Error('Tx has signed outputs, cannot add new one');\n    this.outputs.push(this.normalizeOutput(o));\n    return this.outputs.length - 1;\n  }\n  updateOutput(idx, output, _ignoreSignStatus = false) {\n    this.checkOutputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addOutput || status.outputs.includes(idx)) allowedFields = PSBTOutputUnsignedKeys;\n    }\n    this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n  }\n  addOutputAddress(address, amount, network = NETWORK) {\n    return this.addOutput({\n      script: OutScript.encode(Address(network).decode(address)),\n      amount\n    });\n  }\n  // Utils\n  get fee() {\n    let res = 0n;\n    for (const i of this.inputs) {\n      const prevOut = this.prevOut(i);\n      if (!prevOut) throw new Error('Empty input amount');\n      res += prevOut.amount;\n    }\n    const outputs = this.outputs.map(outputBeforeSign);\n    for (const o of outputs) res -= o.amount;\n    return res;\n  }\n  // Signing\n  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n  // but we are trying to be less complicated for audit purpose for now.\n  preimageLegacy(idx, prevOutScript, hashType) {\n    const {\n      isAny,\n      isNone,\n      isSingle\n    } = unpackSighash(hashType);\n    if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(`Invalid input idx=${idx}`);\n    if (isSingle && idx >= this.outputs.length || idx >= this.inputs.length) return P.U256BE.encode(1n);\n    prevOutScript = Script.encode(Script.decode(prevOutScript).filter(i => i !== 'CODESEPARATOR'));\n    let inputs = this.inputs.map(inputBeforeSign).map((input, inputIdx) => ({\n      ...input,\n      finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY\n    }));\n    if (isAny) inputs = [inputs[idx]];else if (isNone || isSingle) {\n      inputs = inputs.map((input, inputIdx) => ({\n        ...input,\n        sequence: inputIdx === idx ? input.sequence : 0\n      }));\n    }\n    let outputs = this.outputs.map(outputBeforeSign);\n    if (isNone) outputs = [];else if (isSingle) {\n      outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n    }\n    const tmpTx = RawTx.encode({\n      lockTime: this.lockTime,\n      version: this.version,\n      segwitFlag: false,\n      inputs,\n      outputs\n    });\n    return sha256x2(tmpTx, P.I32LE.encode(hashType));\n  }\n  preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n    const {\n      isAny,\n      isNone,\n      isSingle\n    } = unpackSighash(hashType);\n    let inputHash = EMPTY32;\n    let sequenceHash = EMPTY32;\n    let outputHash = EMPTY32;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (!isAny) inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n    if (!isAny && !isSingle && !isNone) sequenceHash = sha256x2(...inputs.map(i => P.U32LE.encode(i.sequence)));\n    if (!isSingle && !isNone) {\n      outputHash = sha256x2(...outputs.map(RawOutput.encode));\n    } else if (isSingle && idx < outputs.length) outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n    const input = inputs[idx];\n    return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n  }\n  preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n    if (!Array.isArray(amount) || this.inputs.length !== amount.length) throw new Error(`Invalid amounts array=${amount}`);\n    if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length) throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n    const out = [P.U8.encode(0), P.U8.encode(hashType), P.I32LE.encode(this.version), P.U32LE.encode(this.lockTime)];\n    const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n    const inType = hashType & SignatureHash.ANYONECANPAY;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (inType !== SignatureHash.ANYONECANPAY) {\n      out.push(...[inputs.map(TxHashIdx.encode), amount.map(P.U64LE.encode), prevOutScript.map(VarBytes.encode), inputs.map(i => P.U32LE.encode(i.sequence))].map(i => sha256(concat(...i))));\n    }\n    if (outType === SignatureHash.ALL) {\n      out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n    }\n    const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n    out.push(new Uint8Array([spendType]));\n    if (inType === SignatureHash.ANYONECANPAY) {\n      const inp = inputs[idx];\n      out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n    } else out.push(P.U32LE.encode(idx));\n    if (spendType & 1) out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n    if (outType === SignatureHash.SINGLE) out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n    if (leafScript) out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n    return schnorr.utils.taggedHash('TapSighash', ...out);\n  }\n  // Utils for sign/finalize\n  // Used pretty often, should be fast\n  prevOut(input) {\n    if (input.nonWitnessUtxo) {\n      if (input.index === undefined) throw new Error('Unknown input index');\n      return input.nonWitnessUtxo.outputs[input.index];\n    } else if (input.witnessUtxo) return input.witnessUtxo;else throw new Error('Cannot find previous output info');\n  }\n  inputType(input) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = this.prevOut(input);\n    const first = OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n      defaultSighash = SignatureHash.DEFAULT;\n      return {\n        txType: 'taproot',\n        type: 'tr',\n        last: first,\n        lastScript: prevOut.script,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash\n      };\n    } else {\n      if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n      if (first.type === 'sh') {\n        if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n        let child = OutScript.decode(input.redeemScript);\n        if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      // wsh can be inside sh\n      if (cur.type === 'wsh') {\n        if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n        let child = OutScript.decode(input.witnessScript);\n        if (child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      const last = stack[stack.length - 1];\n      if (last.type === 'sh' || last.type === 'wsh') throw new Error('inputType: sh/wsh cannot be terminal type');\n      const lastScript = OutScript.encode(last);\n      const res = {\n        type,\n        txType,\n        last,\n        lastScript,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash\n      };\n      if (txType === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n        throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n      }\n      return res;\n    }\n  }\n  // Signer can be privateKey OR instance of bip32 HD stuff\n  signIdx(privateKey, idx, allowedSighash, _auxRand) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Handle BIP32 HDKey\n    if (!isBytes(privateKey)) {\n      if (!input.bip32Derivation || !input.bip32Derivation.length) throw new Error('bip32Derivation: empty');\n      const signers = input.bip32Derivation.filter(i => i[1].fingerprint == privateKey.fingerprint).map(([pubKey, {\n        path\n      }]) => {\n        let s = privateKey;\n        for (const i of path) s = s.deriveChild(i);\n        if (!P.equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n        if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n        return s;\n      });\n      if (!signers.length) throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n      let signed = false;\n      for (const s of signers) if (this.signIdx(s.privateKey, idx)) signed = true;\n      return signed;\n    }\n    // Sighash checks\n    // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n    if (!allowedSighash) allowedSighash = [inputType.defaultSighash];else allowedSighash.forEach(validateSigHash);\n    const sighash = inputType.sighash;\n    if (!allowedSighash.includes(sighash)) {\n      throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n    }\n    // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n    // however this was because of bug in bitcoin-core, which remains here because of consensus.\n    // If this is absolutely neccessary for your case, please open issue.\n    // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n    const {\n      sigOutputs\n    } = this.inputSighash(idx);\n    if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n      throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n    }\n    // Actual signing\n    // Taproot\n    const prevOut = this.prevOut(input);\n    if (inputType.txType === 'taproot') {\n      if (input.tapBip32Derivation) throw new Error('tapBip32Derivation unsupported');\n      const prevOuts = this.inputs.map(this.prevOut);\n      const prevOutScript = prevOuts.map(i => i.script);\n      const amount = prevOuts.map(i => i.amount);\n      let signed = false;\n      let schnorrPub = schnorr.getPublicKey(privateKey);\n      let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n      if (input.tapInternalKey) {\n        // internal + tweak = tweaked key\n        // if internal key == current public key, we need to tweak private key,\n        // otherwise sign as is. bitcoinjs implementation always wants tweaked\n        // priv key to be provided\n        const {\n          pubKey,\n          privKey\n        } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n        const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n        if (P.equalBytes(taprootPubKey, pubKey)) {\n          const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n          const sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n          this.updateInput(idx, {\n            tapKeySig: sig\n          }, true);\n          signed = true;\n        }\n      }\n      if (input.tapLeafScript) {\n        input.tapScriptSig = input.tapScriptSig || [];\n        for (const [_, _script] of input.tapLeafScript) {\n          const script = _script.subarray(0, -1);\n          const scriptDecoded = Script.decode(script);\n          const ver = _script[_script.length - 1];\n          const hash = tapLeafHash(script, ver);\n          // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n          const pos = scriptDecoded.findIndex(i => isBytes(i) && P.equalBytes(i, schnorrPub));\n          // Skip if there is no public key in tapLeafScript\n          if (pos === -1) continue;\n          const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n          const sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n          this.updateInput(idx, {\n            tapScriptSig: [[{\n              pubKey: schnorrPub,\n              leafHash: hash\n            }, sig]]\n          }, true);\n          signed = true;\n        }\n      }\n      if (!signed) throw new Error('No taproot scripts signed');\n      return true;\n    } else {\n      // only compressed keys are supported for now\n      const pubKey = _pubECDSA(privateKey);\n      // TODO: replace with explicit checks\n      // Check if script has public key or its has inside\n      let hasPubkey = false;\n      const pubKeyHash = hash160(pubKey);\n      for (const i of Script.decode(inputType.lastScript)) {\n        if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash))) hasPubkey = true;\n      }\n      if (!hasPubkey) throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n      let hash;\n      if (inputType.txType === 'legacy') {\n        hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n      } else if (inputType.txType === 'segwit') {\n        let script = inputType.lastScript;\n        // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n        if (inputType.last.type === 'wpkh') script = OutScript.encode({\n          type: 'pkh',\n          hash: inputType.last.hash\n        });\n        hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n      } else throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n      const sig = signECDSA(hash, privateKey, this.opts.lowR);\n      this.updateInput(idx, {\n        partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]]\n      }, true);\n    }\n    return true;\n  }\n  // This is bad API. Will work if user creates and signs tx, but if\n  // there is some complex workflow with exchanging PSBT and signing them,\n  // then it is better to validate which output user signs. How could a better API look like?\n  // Example: user adds input, sends to another party, then signs received input (mixer etc),\n  // another user can add different input for same key and user will sign it.\n  // Even worse: another user can add bip32 derivation, and spend money from different address.\n  // Better api: signIdx\n  sign(privateKey, allowedSighash, _auxRand) {\n    let num = 0;\n    for (let i = 0; i < this.inputs.length; i++) {\n      try {\n        if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n      } catch (e) {}\n    }\n    if (!num) throw new Error('No inputs signed');\n    return num;\n  }\n  finalizeIdx(idx) {\n    this.checkInputIdx(idx);\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Taproot finalize\n    if (inputType.txType === 'taproot') {\n      if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];else if (input.tapLeafScript && input.tapScriptSig) {\n        // Sort leafs by control block length.\n        const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n        for (const [cb, _script] of leafs) {\n          // Last byte is version\n          const script = _script.slice(0, -1);\n          const ver = _script[_script.length - 1];\n          const outScript = OutScript.decode(script);\n          const hash = tapLeafHash(script, ver);\n          const scriptSig = input.tapScriptSig.filter(i => P.equalBytes(i[0].leafHash, hash));\n          let signatures = [];\n          if (outScript.type === 'tr_ms') {\n            const m = outScript.m;\n            const pubkeys = outScript.pubkeys;\n            let added = 0;\n            for (const pub of pubkeys) {\n              const sigIdx = scriptSig.findIndex(i => P.equalBytes(i[0].pubKey, pub));\n              // Should have exact amount of signatures (more -- will fail)\n              if (added === m || sigIdx === -1) {\n                signatures.push(P.EMPTY);\n                continue;\n              }\n              signatures.push(scriptSig[sigIdx][1]);\n              added++;\n            }\n            // Should be exact same as m\n            if (added !== m) continue;\n          } else if (outScript.type === 'tr_ns') {\n            for (const pub of outScript.pubkeys) {\n              const sigIdx = scriptSig.findIndex(i => P.equalBytes(i[0].pubKey, pub));\n              if (sigIdx === -1) continue;\n              signatures.push(scriptSig[sigIdx][1]);\n            }\n            if (signatures.length !== outScript.pubkeys.length) continue;\n          } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n            // Trying our best to sign what we can\n            const scriptDecoded = Script.decode(script);\n            signatures = scriptSig.map(([{\n              pubKey\n            }, signature]) => {\n              const pos = scriptDecoded.findIndex(i => isBytes(i) && P.equalBytes(i, pubKey));\n              if (pos === -1) throw new Error('finalize/taproot: cannot find position of pubkey in script');\n              return {\n                signature,\n                pos\n              };\n            })\n            // Reverse order (because witness is stack and we take last element first from it)\n            .sort((a, b) => a.pos - b.pos).map(i => i.signature);\n            if (!signatures.length) continue;\n          } else throw new Error('Finalize: Unknown tapLeafScript');\n          // Witness is stack, so last element will be used first\n          input.finalScriptWitness = signatures.reverse().concat([script, TaprootControlBlock.encode(cb)]);\n          break;\n        }\n        if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n      } else throw new Error('finalize/taproot: unknown input');\n      input.finalScriptSig = P.EMPTY;\n      cleanFinalInput(input);\n      return;\n    }\n    if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n    let inputScript = P.EMPTY;\n    let witness = [];\n    // TODO: move input scripts closer to payments/output scripts\n    // Multisig\n    if (inputType.last.type === 'ms') {\n      const m = inputType.last.m;\n      const pubkeys = inputType.last.pubkeys;\n      let signatures = [];\n      // partial: [pubkey, sign]\n      for (const pub of pubkeys) {\n        const sign = input.partialSig.find(s => P.equalBytes(pub, s[0]));\n        if (!sign) continue;\n        signatures.push(sign[1]);\n      }\n      signatures = signatures.slice(0, m);\n      if (signatures.length !== m) {\n        throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n      }\n      inputScript = Script.encode([0, ...signatures]);\n    } else if (inputType.last.type === 'pk') {\n      inputScript = Script.encode([input.partialSig[0][1]]);\n    } else if (inputType.last.type === 'pkh') {\n      inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n    } else if (inputType.last.type === 'wpkh') {\n      inputScript = P.EMPTY;\n      witness = [input.partialSig[0][1], input.partialSig[0][0]];\n    } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs) throw new Error('Unknown inputs not allowed');\n    // Create final scripts (generic part)\n    let finalScriptSig, finalScriptWitness;\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        witness = Script.decode(inputScript).map(i => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      witness = witness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') finalScriptWitness = witness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {} else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n    if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n    if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n    if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n    cleanFinalInput(input);\n  }\n  finalize() {\n    for (let i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n  }\n  extract() {\n    if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n    if (!this.outputs.length) throw new Error('Transaction has no outputs');\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    return this.toBytes(true, true);\n  }\n  combine(other) {\n    for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n      if (this.opts[k] !== other.opts[k]) {\n        throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n      }\n    }\n    for (const k of ['inputs', 'outputs']) {\n      if (this[k].length !== other[k].length) {\n        throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n      }\n    }\n    const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n    const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n    if (!P.equalBytes(thisUnsigned, otherUnsigned)) throw new Error(`Transaction/combine: different unsigned tx`);\n    this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n    for (let i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n    for (let i = 0; i < this.outputs.length; i++) this.updateOutput(i, other.outputs[i], true);\n    return this;\n  }\n  clone() {\n    // deepClone probably faster, but this enforces that encoding is valid\n    return Transaction.fromPSBT(this.toPSBT(2), this.opts);\n  }\n}\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey, network = NETWORK) {\n  if (type === 'tr') {\n    return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n  }\n  const pubKey = _pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(`getAddress: unknown type=${type}`);\n}\nexport function multisig(m, pubkeys, sorted = false, witness = false) {\n  const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys, witness = false) {\n  return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n  const out = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  const parts = path.replace(/^[mM]'?\\//, '').split('/');\n  for (const c of parts) {\n    const m = /^(\\d+)('?)$/.exec(c);\n    if (!m || m.length !== 3) throw new Error(`Invalid child index: ${c}`);\n    let idx = +m[1];\n    if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n    // hardened key\n    if (m[2] === \"'\") idx += HARDENED_OFFSET;\n    out.push(idx);\n  }\n  return out;\n}\nexport function PSBTCombine(psbts) {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length) throw new Error('PSBTCombine: wrong PSBT list');\n  const tx = Transaction.fromPSBT(psbts[0]);\n  for (let i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}","map":{"version":3,"names":["secp256k1","_secp","schnorr","sha256","ripemd160","hex","base58check","_b58","bech32","bech32m","P","ProjectivePoint","ProjPoint","sign","_signECDSA","getPublicKey","_pubECDSA","CURVE_ORDER","CURVE","n","def","value","undefined","isBytes","hash160","msg","sha256x2","msgs","concat","concatBytes","cloneDeep","obj","Array","isArray","map","i","Uint8Array","from","includes","Object","fromEntries","entries","k","v","Error","PubT","validatePubkey","pub","type","len","length","ecdsa","fromHex","utils","lift_x","bytesToNumberBE","isValidPubkey","e","hasLowR","sig","r","signECDSA","hash","privateKey","lowR","extraEntropy","cnt","Number","MAX_SAFE_INTEGER","set","U32LE","encode","toDERRawBytes","tapTweak","a","b","u","t","taggedHash","tn","taprootTweakPrivKey","privKey","merkleRoot","seckey0","fromPrivateKey","seckey","hasEvenY","mod","xP","pointToBytes","numberToBytesBE","taprootTweakPubkey","pubKey","h","Q","add","parity","PubKeyECDSA","validate","bytes","PubKeySchnorr","SignatureSchnorr","uniqPubkey","pubkeys","key","NETWORK","pubKeyHash","scriptHash","wif","TEST_NETWORK","PRECISION","DEFAULT_VERSION","DEFAULT_LOCKTIME","DEFAULT_SEQUENCE","EMPTY32","Decimal","coders","decimal","_cmpBytes","Math","min","OP","Script","wrap","encodeStream","w","o","byte","OP_1","ScriptNum","BigInt","PUSHDATA1","PUSHDATA2","U16LE","PUSHDATA4","decodeStream","out","isEnd","cur","OP_0","U8","push","OP_16","op","toString","bytesLimit","forceMinimal","neg","val","nums","abs","leftBytes","data","last","res","OpToNum","decode","CSLimits","CompactSize","flag","start","stop","values","err","b0","_","num","CompactSizeLen","apply","number","BTCArray","array","VarBytes","RawInput","struct","txid","index","finalScriptSig","sequence","RawOutput","amount","U64LE","script","EMPTY_OUTPUT","EMPTY","RawWitness","_RawTx","version","I32LE","segwitFlag","inputs","outputs","witnesses","flagged","lockTime","validateRawTx","tx","RawTx","PSBTKeyInfo","info","kc","vc","reqInc","allowInc","silentIgnore","BIP32Der","fingerprint","U32BE","path","_TaprootControlBlock","internalKey","merklePath","TaprootControlBlock","cb","TaprootBIP32Der","hashes","der","GlobalXPUB","tapScriptSigKey","leafHash","tapTree","depth","BytesInf","Bytes20","Bytes32","PSBTGlobal","unsignedTx","xpub","txVersion","fallbackLocktime","inputCount","outputCount","txModifiable","proprietary","PSBTInput","nonWitnessUtxo","witnessUtxo","partialSig","sighashType","redeemScript","witnessScript","bip32Derivation","finalScriptWitness","porCommitment","hash256","requiredTimeLocktime","requiredHeightLocktime","tapKeySig","tapScriptSig","tapLeafScript","tapBip32Derivation","tapInternalKey","tapMerkleRoot","PSBTInputFinalKeys","PSBTInputUnsignedKeys","PSBTOutput","I64LE","PSBTOutputUnsignedKeys","PSBTKeyPair","NULL","prefix","PSBTUnknownKey","PSBTKeyMap","psbtEnum","byType","name","kv","sort","unknown","raw","noKey","elm","_name","checkWSH","s","equalBytes","OutScript","checkScript","PSBTInputCoder","prevOut","Transaction","fromRaw","id","PSBTOutputCoder","PSBTGlobalCoder","g","inp","_RawPSBTV0","magic","string","global","_RawPSBTV2","_DebugPSBT","items","tuple","dict","validatePSBTFields","lst","cleanPSBTFields","_k","validatePSBT","inputsLeft","slice","keys","outputsLeft","mergeKeyMap","allowedFields","kC","vC","cannotChange","oldKV","newKV","kStr","oldVal","newVal","RawPSBTV0","RawPSBTV2","TxHashIdx","OutPK","pubkey","to","p2pk","network","OutPKH","p2pkh","publicKey","address","Address","OutSH","p2sh","child","cs","OutWSH","p2wsh","OutWPKH","p2wpkh","OutMS","m","p2ms","allowSamePubkeys","OutTR","taprootListToTree","taprootList","weight","pop","childs","checkTaprootScript","internalPubKey","allowUnknownOutputs","outms","p","TAPROOT_UNSPENDABLE_KEY","taprootHashTree","tree","leafVersion","leafScript","tapLeafHash","left","right","lH","rH","taprootAddPath","taprootWalkTree","BASE","toRawBytes","p2tr","hashedTree","tweakedPubkey","leaves","l","controlBlock","TAP_LEAF_VERSION","OutTRNS","combinations","list","idx","main","p2tr_ns","p2tr_pk","OutTRMS","p2tr_ms","OutUnknown","OutScripts","_OutScript","match","validateWitness","programToWitness","coder","toWords","formatKey","hashed","WIF","compressed","subarray","parsed","toLowerCase","startsWith","words","program","fromWords","SignatureHash","SigHash","validateSigHash","unpackSighash","hashType","masked","isAny","ANYONECANPAY","isNone","NONE","isSingle","SINGLE","_sortPubkeys","inputBeforeSign","cleanFinalInput","outputBeforeSign","getTaprootKeys","toStr","validateOpts","opts","call","_opts","PSBTVersion","allowUnknowInput","allowUnknownInputs","allowUnknowOutput","freeze","constructor","addOutput","fromPSBT","psbt","e0","e2","unsigned","j","toPSBT","bip174jsCompat","height","heightCnt","time","timeCnt","max","inputStatus","checkInputIdx","input","inputSighash","sighash","inputType","sigOutputs","DEFAULT","ALL","sigInputs","signStatus","addInput","status","isFinal","hasWitnesses","vsize","ceil","toBytes","withScriptSig","withWitness","reverse","isSafeInteger","getInput","inputsLength","normalizeInput","disableScriptCheck","_ignoreSignStatus","updateInput","checkOutputIdx","getOutput","outputsLength","normalizeOutput","updateOutput","output","addOutputAddress","fee","preimageLegacy","prevOutScript","U256BE","filter","inputIdx","fill","tmpTx","preimageWitnessV0","inputHash","sequenceHash","outputHash","preimageWitnessV1","codeSeparator","leafVer","annex","outType","inType","spendType","txType","defaultSighash","first","stack","lastScript","allowLegacyWitnessUtxo","signIdx","allowedSighash","_auxRand","signers","deriveChild","signed","forEach","join","prevOuts","schnorrPub","taprootPubKey","_script","scriptDecoded","ver","pos","findIndex","hasPubkey","finalizeIdx","leafs","outScript","scriptSig","signatures","added","sigIdx","signature","inputScript","witness","find","finalize","extract","combine","other","thisUnsigned","otherUnsigned","clone","getAddress","multisig","sorted","ms","sortedMultisig","HARDENED_OFFSET","bip32Path","test","parts","replace","split","c","exec","PSBTCombine","psbts"],"sources":["/Volumes/Data/sats-connect-example-main/node_modules/@scure/btc-signer/index.ts"],"sourcesContent":["/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, base58check as _b58, bech32, bech32m } from '@scure/base';\nimport type { Coder } from '@scure/base';\nimport * as P from 'micro-packed';\n\nconst { ProjectivePoint: ProjPoint, sign: _signECDSA, getPublicKey: _pubECDSA } = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n\n// Basic utility types\nexport type ExtendType<T, E> = {\n  [K in keyof T]: K extends keyof E ? E[K] | T[K] : T[K];\n};\nexport type RequireType<T, K extends keyof T> = T & {\n  [P in K]-?: T[P];\n};\nexport type Bytes = Uint8Array;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = <T>(value: T | undefined, def: T) => (value === undefined ? def : value);\nconst isBytes = P.isBytes;\nconst hash160 = (msg: Bytes) => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs: Bytes[]) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = _b58(sha256);\n\nexport function cloneDeep<T>(obj: T): T {\n  if (Array.isArray(obj)) return obj.map((i) => cloneDeep(i)) as unknown as T;\n  // slice of nodejs Buffer doesn't copy\n  else if (obj instanceof Uint8Array) return Uint8Array.from(obj) as unknown as T;\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)])\n    ) as unknown as T;\n  }\n  throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\n\nenum PubT {\n  ecdsa,\n  schnorr,\n}\nfunction validatePubkey(pub: Bytes, type: PubT): Bytes {\n  const len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    ProjPoint.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\n\nfunction isValidPubkey(pub: Bytes, type: PubT): boolean {\n  try {\n    validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig: { r: bigint; s: bigint }) => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash: Bytes, privateKey: Bytes, lowR = false): Bytes {\n  let sig = _signECDSA(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    const extraEntropy = new Uint8Array(32);\n    for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n      extraEntropy.set(P.U32LE.encode(cnt));\n      sig = _signECDSA(hash, privateKey, { extraEntropy });\n      if (hasLowR(sig)) break;\n    }\n  }\n  return sig.toDERRawBytes();\n}\n\nfunction tapTweak(a: Bytes, b: Bytes): bigint {\n  const u = schnorr.utils;\n  const t = u.taggedHash('TapTweak', a, b);\n  const tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\n\nexport function taprootTweakPrivKey(privKey: Uint8Array, merkleRoot = new Uint8Array()) {\n  const u = schnorr.utils;\n  const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  const xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  const t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\n\nexport function taprootTweakPubkey(pubKey: Uint8Array, h: Uint8Array): [Uint8Array, number] {\n  const u = schnorr.utils;\n  const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), (pub) => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), (pub) => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), (sig) => {\n  if (sig.length !== 64 && sig.length !== 65)\n    throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\n\nfunction uniqPubkey(pubkeys: Bytes[]) {\n  const map: Record<string, boolean> = {};\n  for (const pub of pubkeys) {\n    const key = hex.encode(pub);\n    if (map[key]) throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n    map[key] = true;\n  }\n}\n\nexport const NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\n\nexport const TEST_NETWORK: typeof NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a: Bytes, b: Bytes) {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n\n// Coders\n// prettier-ignore\nexport enum OP {\n  OP_0 = 0x00, PUSHDATA1 = 0x4c, PUSHDATA2, PUSHDATA4, '1NEGATE',\n  RESERVED = 0x50,\n  OP_1, OP_2, OP_3, OP_4, OP_5, OP_6, OP_7, OP_8,\n  OP_9, OP_10, OP_11, OP_12, OP_13, OP_14, OP_15, OP_16,\n  // Control\n  NOP, VER, IF, NOTIF, VERIF, VERNOTIF, ELSE, ENDIF, VERIFY, RETURN,\n  // Stack\n  TOALTSTACK, FROMALTSTACK, '2DROP', '2DUP', '3DUP', '2OVER', '2ROT', '2SWAP',\n  IFDUP, DEPTH, DROP, DUP, NIP, OVER, PICK, ROLL, ROT, SWAP, TUCK,\n  // Splice\n  CAT, SUBSTR, LEFT, RIGHT, SIZE,\n  // Boolean logic\n  INVERT, AND, OR, XOR, EQUAL, EQUALVERIFY, RESERVED1, RESERVED2,\n  // Numbers\n  '1ADD', '1SUB', '2MUL', '2DIV',\n  NEGATE, ABS, NOT, '0NOTEQUAL',\n  ADD, SUB, MUL, DIV, MOD, LSHIFT, RSHIFT, BOOLAND, BOOLOR,\n  NUMEQUAL, NUMEQUALVERIFY, NUMNOTEQUAL, LESSTHAN, GREATERTHAN,\n  LESSTHANOREQUAL, GREATERTHANOREQUAL, MIN, MAX, WITHIN,\n  // Crypto\n  RIPEMD160, SHA1, SHA256, HASH160, HASH256, CODESEPARATOR,\n  CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY,\n  // Expansion\n  NOP1, CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY, NOP4, NOP5, NOP6, NOP7, NOP8, NOP9, NOP10,\n  // BIP 342\n  CHECKSIGADD,\n  // Invalid\n  INVALID = 0xff,\n}\n\ntype ScriptOP = keyof typeof OP | Bytes | number;\n\ntype ScriptType = ScriptOP[];\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script: P.CoderType<ScriptType> = P.wrap({\n  encodeStream: (w: P.Writer, value: ScriptType) => {\n    for (let o of value) {\n      if (typeof o === 'string') {\n        if (OP[o] === undefined) throw new Error(`Unknown opcode=${o}`);\n        w.byte(OP[o]);\n        continue;\n      } else if (typeof o === 'number') {\n        if (o === 0x00) {\n          w.byte(0x00);\n          continue;\n        } else if (1 <= o && o <= 16) {\n          w.byte(OP.OP_1 - 1 + o);\n          continue;\n        }\n      }\n      // Encode big numbers\n      if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n      if (!isBytes(o)) throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n      // Bytes\n      const len = o.length;\n      if (len < OP.PUSHDATA1) w.byte(len);\n      else if (len <= 0xff) {\n        w.byte(OP.PUSHDATA1);\n        w.byte(len);\n      } else if (len <= 0xffff) {\n        w.byte(OP.PUSHDATA2);\n        w.bytes(P.U16LE.encode(len));\n      } else {\n        w.byte(OP.PUSHDATA4);\n        w.bytes(P.U32LE.encode(len));\n      }\n      w.bytes(o);\n    }\n  },\n  decodeStream: (r: P.Reader): ScriptType => {\n    const out: ScriptType = [];\n    while (!r.isEnd()) {\n      const cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        let len;\n        if (cur < OP.PUSHDATA1) len = cur;\n        else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);\n        else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);\n        else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);\n        else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        const op = OP[cur] as keyof typeof OP;\n        if (op === undefined) throw new Error(`Unknown opcode=${cur.toString(16)}`);\n        out.push(op);\n      }\n    }\n    return out;\n  },\n});\n\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false): P.CoderType<bigint> {\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: bigint) => {\n      if (value === 0n) return;\n      const neg = value < 0;\n      const val = BigInt(value);\n      const nums = [];\n      for (let abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);\n      else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: (r: P.Reader): bigint => {\n      const len = r.leftBytes;\n      if (len > bytesLimit)\n        throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((r.data[len - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (r.data[len - 2] & 0x80) === 0)\n            throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      let last = 0;\n      let res = 0n;\n      for (let i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << (8n * BigInt(i));\n      }\n      if (last >= 0x80) {\n        res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n        res = -res;\n      }\n      return res;\n    },\n  });\n}\n\nexport function OpToNum(op: ScriptOP, bytesLimit = 4, forceMinimal = true) {\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits: Record<number, [number, number, bigint, bigint]> = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize: P.CoderType<bigint> = P.wrap({\n  encodeStream: (w: P.Writer, value: bigint) => {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (let i = 0; i < bytes; i++) w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n      return;\n    }\n    throw w.err(`VarInt too big: ${value}`);\n  },\n  decodeStream: (r: P.Reader): bigint => {\n    const b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    const [_, bytes, start] = CSLimits[b0];\n    let num = 0n;\n    for (let i = 0; i < bytes; i++) num |= BigInt(r.byte()) << (8n * BigInt(i));\n    if (num < start) throw r.err(`Wrong CompactSize(${8 * bytes})`);\n    return num;\n  },\n});\n\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n\n// Array of size <CompactSize>\nexport const BTCArray = <T>(t: P.CoderType<T>): P.CoderType<T[]> => P.array(CompactSize, t);\n\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\n\nexport const RawInput = P.struct({\n  txid: P.bytes(32, true), // hash(prev_tx),\n  index: P.U32LE, // output number of previous tx\n  finalScriptSig: VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n  sequence: P.U32LE, // ?\n});\n\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\nconst EMPTY_OUTPUT: P.UnwrapCoder<typeof RawOutput> = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY,\n};\n\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE,\n});\n\nfunction validateRawTx(tx: P.UnwrapCoder<typeof _RawTx>) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n    throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\n\n// PSBT BIP174, BIP370, BIP371\n\ntype PSBTKeyCoder = P.CoderType<any> | false;\n\ntype PSBTKeyMapInfo = Readonly<\n  [\n    number,\n    PSBTKeyCoder,\n    any,\n    readonly number[], // versionsRequiringInclusion\n    readonly number[], // versionsAllowsInclusion\n    boolean // silentIgnore\n  ]\n>;\n\nfunction PSBTKeyInfo(info: PSBTKeyMapInfo) {\n  const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n  return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\n\ntype PSBTKeyMap = Record<string, PSBTKeyMapInfo>;\n\nconst BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE),\n});\n\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n  version: P.U8, // With parity :(\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n  if (cb.merklePath.length > 128)\n    throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\n\nconst TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(\n  null,\n  P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n  })\n);\n\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n  unsignedTx:       [0x00, false,      RawTx,          [0], [0],    false],\n  xpub:             [0x01, GlobalXPUB, BIP32Der,       [],  [0, 2], false],\n  txVersion:        [0x02, false,      P.U32LE,        [2], [2],    false],\n  fallbackLocktime: [0x03, false,      P.U32LE,        [],  [2],    false],\n  inputCount:       [0x04, false,      CompactSizeLen, [2], [2],    false],\n  outputCount:      [0x05, false,      CompactSizeLen, [2], [2],    false],\n  txModifiable:     [0x06, false,      P.U8,           [],  [2],    false],   // TODO: bitfield\n  version:          [0xfb, false,      P.U32LE,        [],  [0, 2], false],\n  proprietary:      [0xfc, BytesInf,   BytesInf,       [],  [0, 2], false],\n} as const;\n// prettier-ignore\nconst PSBTInput = {\n  nonWitnessUtxo:         [0x00, false,               RawTx,            [],  [0, 2], false],\n  witnessUtxo:            [0x01, false,               RawOutput,        [],  [0, 2], false],\n  partialSig:             [0x02, PubKeyECDSA,         BytesInf,         [],  [0, 2], false],\n  sighashType:            [0x03, false,               P.U32LE,          [],  [0, 2], false],\n  redeemScript:           [0x04, false,               BytesInf,         [],  [0, 2], false],\n  witnessScript:          [0x05, false,               BytesInf,         [],  [0, 2], false],\n  bip32Derivation:        [0x06, PubKeyECDSA,         BIP32Der,         [],  [0, 2], false],\n  finalScriptSig:         [0x07, false,               BytesInf,         [],  [0, 2], false],\n  finalScriptWitness:     [0x08, false,               RawWitness,       [],  [0, 2], false],\n  porCommitment:          [0x09, false,               BytesInf,         [],  [0, 2], false],\n  ripemd160:              [0x0a, Bytes20,             BytesInf,         [],  [0, 2], false],\n  sha256:                 [0x0b, Bytes32,             BytesInf,         [],  [0, 2], false],\n  hash160:                [0x0c, Bytes20,             BytesInf,         [],  [0, 2], false],\n  hash256:                [0x0d, Bytes32,             BytesInf,         [],  [0, 2], false],\n  txid:                   [0x0e, false,               Bytes32,          [2], [2],    true],\n  index:                  [0x0f, false,               P.U32LE,          [2], [2],    true],\n  sequence:               [0x10, false,               P.U32LE,          [],  [2],    true],\n  requiredTimeLocktime:   [0x11, false,               P.U32LE,          [],  [2],    false],\n  requiredHeightLocktime: [0x12, false,               P.U32LE,          [],  [2],    false],\n  tapKeySig:              [0x13, false,               SignatureSchnorr, [],  [0, 2], false],\n  tapScriptSig:           [0x14, tapScriptSigKey,     SignatureSchnorr, [],  [0, 2], false],\n  tapLeafScript:          [0x15, TaprootControlBlock, BytesInf,         [],  [0, 2], false],\n  tapBip32Derivation:     [0x16, Bytes32,             TaprootBIP32Der,  [],  [0, 2], false],\n  tapInternalKey:         [0x17, false,               PubKeySchnorr,    [],  [0, 2], false],\n  tapMerkleRoot:          [0x18, false,               Bytes32,          [],  [0, 2], false],\n  proprietary:            [0xfc, BytesInf,            BytesInf,         [],  [0, 2], false],\n} as const;\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys: (keyof TransactionInput)[] = [\n  'txid',\n  'sequence',\n  'index',\n  'witnessUtxo',\n  'nonWitnessUtxo',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'unknown',\n];\n\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys: (keyof TransactionInput)[] = [\n  'partialSig',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'tapKeySig',\n  'tapScriptSig',\n];\n\n// prettier-ignore\nconst PSBTOutput = {\n  redeemScript:       [0x00, false,         BytesInf,        [],  [0, 2], false],\n  witnessScript:      [0x01, false,         BytesInf,        [],  [0, 2], false],\n  bip32Derivation:    [0x02, PubKeyECDSA,   BIP32Der,        [],  [0, 2], false],\n  amount:             [0x03, false,         P.I64LE,         [2], [2],    true],\n  script:             [0x04, false,         BytesInf,        [2], [2],    true],\n  tapInternalKey:     [0x05, false,         PubKeySchnorr,   [],  [0, 2], false],\n  tapTree:            [0x06, false,         tapTree,         [],  [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [],  [0, 2], false],\n  proprietary:        [0xfc, BytesInf,      BytesInf,        [],  [0, 2], false],\n} as const;\n\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys: (keyof typeof PSBTOutput)[] = [];\n\nconst PSBTKeyPair = P.array(\n  P.NULL,\n  P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n  })\n);\n\nconst PSBTUnknownKey = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\ntype PSBTUnknownFields = { unknown?: [P.UnwrapCoder<typeof PSBTUnknownKey>, Bytes][] };\ntype PSBTKeyMapKeys<T extends PSBTKeyMap> = {\n  -readonly [K in keyof T]?: T[K][1] extends false\n    ? P.UnwrapCoder<T[K][2]>\n    : [P.UnwrapCoder<T[K][1]>, P.UnwrapCoder<T[K][2]>][];\n} & PSBTUnknownFields;\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap<T extends PSBTKeyMap>(psbtEnum: T): P.CoderType<PSBTKeyMapKeys<T>> {\n  // -> Record<type, [keyName, ...coders]>\n  const byType: Record<number, [string, PSBTKeyCoder, P.CoderType<any>]> = {};\n  for (const k in psbtEnum) {\n    const [num, kc, vc] = psbtEnum[k];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: PSBTKeyMapKeys<T>) => {\n      let out: P.UnwrapCoder<typeof PSBTKeyPair> = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      for (const name in psbtEnum) {\n        const val = value[name];\n        if (val === undefined) continue;\n        const [type, kc, vc] = psbtEnum[name];\n        if (!kc) {\n          out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          const kv: [Bytes, Bytes][] = val!.map(\n            ([k, v]: [P.UnwrapCoder<typeof kc>, P.UnwrapCoder<typeof vc>]) => [\n              kc.encode(k),\n              vc.encode(v),\n            ]\n          );\n          // sort by keys\n          kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n          for (const [key, value] of kv) out.push({ key: { key, type }, value });\n        }\n      }\n      if (value.unknown) {\n        value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n        for (const [k, v] of value.unknown) out.push({ key: k, value: v });\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: (r: P.Reader): PSBTKeyMapKeys<T> => {\n      const raw = PSBTKeyPair.decodeStream(r);\n      const out: any = {};\n      const noKey: Record<string, true> = {};\n      for (const elm of raw) {\n        let name = 'unknown';\n        let key: any = elm.key.key;\n        let value = elm.value;\n        if (byType[elm.key.type]) {\n          const [_name, kc, vc] = byType[elm.key.type];\n          name = _name;\n          if (!kc && key.length) {\n            throw new Error(\n              `PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`\n            );\n          }\n          key = kc ? kc.decode(key) : undefined;\n          value = vc.decode(value);\n          if (!kc) {\n            if (out[name]) throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n            out[name] = value;\n            noKey[name] = true;\n            continue;\n          }\n        } else {\n          // For unknown: add key type inside key\n          key = { type: elm.key.type, key: elm.key.key };\n        }\n        // Only keyed elements at this point\n        if (noKey[name])\n          throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n        if (!out[name]) out[name] = [];\n        out[name].push([key, value]);\n      }\n      return out;\n    },\n  });\n}\n\n// Basic sanity check for scripts\nfunction checkWSH(s: OutWSHType, witnessScript: Bytes) {\n  if (!P.equalBytes(s.hash, sha256(witnessScript)))\n    throw new Error('checkScript: wsh wrong witnessScript hash');\n  const w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n  if (w.type === 'wpkh' || w.type === 'sh')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\n\nfunction checkScript(script?: Bytes, redeemScript?: Bytes, witnessScript?: Bytes) {\n  if (script) {\n    const s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n      throw new Error(`checkScript: non-wrapped ${s.type}`);\n    if (s.type === 'sh' && redeemScript) {\n      if (!P.equalBytes(s.hash, hash160(redeemScript)))\n        throw new Error('checkScript: sh wrong redeemScript hash');\n      const r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n        throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    const r = OutScript.decode(redeemScript);\n    if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);\n  }\n}\n\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length)\n    throw new Error('validateInput: wmpty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) for (const [k] of i.partialSig) validatePubkey(k, PubT.ecdsa);\n  if (i.bip32Derivation) for (const [k] of i.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n    throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (\n    i.requiredHeightLocktime !== undefined &&\n    (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)\n  )\n    throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    const last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n    const prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (\n      i.witnessUtxo &&\n      (!P.equalBytes(i.witnessUtxo.script, prevOut.script) ||\n        i.witnessUtxo.amount !== prevOut.amount)\n    )\n      throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n  }\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    for (const [k, v] of i.tapLeafScript) {\n      if ((k.version & 0b1111_1110) !== v[v.length - 1])\n        throw new Error('validateInput: tapLeafScript version mimatch');\n      if (v[v.length - 1] & 1)\n        throw new Error('validateInput: tapLeafScript version has parity bit!');\n    }\n  }\n  // Validate txid for nonWitnessUtxo is correct\n  if (i.nonWitnessUtxo && i.index && i.txid) {\n    const outputs = i.nonWitnessUtxo.outputs;\n    if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n    const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo));\n    const txid = hex.encode(i.txid);\n    if (tx.id !== txid) throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n  }\n  return i;\n});\n\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n  if (o.bip32Derivation) for (const [k] of o.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  return o;\n});\n\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n  const version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses)\n      throw new Error('PSBTv0: witness in unsingedTx');\n    for (const inp of g.unsignedTx.inputs)\n      if (inp.finalScriptSig && inp.finalScriptSig.length)\n        throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n  }\n  return g;\n});\n\nexport const _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder),\n});\n\nexport const _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\n\nexport type PSBTRaw = typeof _RawPSBTV0 | typeof _RawPSBTV2;\n\nexport const _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(\n    null,\n    P.apply(\n      P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])),\n      P.coders.dict()\n    )\n  ),\n});\n\nfunction validatePSBTFields<T extends PSBTKeyMap>(\n  version: number,\n  info: T,\n  lst: PSBTKeyMapKeys<T>\n) {\n  for (const k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    const { allowInc } = PSBTKeyInfo(info[k]);\n    if (!allowInc.includes(version)) throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n  }\n  for (const k in info) {\n    const { reqInc } = PSBTKeyInfo(info[k]);\n    if (reqInc.includes(version) && lst[k] === undefined)\n      throw new Error(`PSBTv${version}: missing required field ${k}`);\n  }\n}\n\nfunction cleanPSBTFields<T extends PSBTKeyMap>(version: number, info: T, lst: PSBTKeyMapKeys<T>) {\n  const out: PSBTKeyMapKeys<T> = {};\n  for (const _k in lst) {\n    const k = _k as string & keyof PSBTKeyMapKeys<T>;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(\n          `Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`\n        );\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\n\nfunction validatePSBT(tx: P.UnwrapCoder<PSBTRaw>) {\n  const version = (tx && tx.global && tx.global.version) || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  for (const i of tx.inputs) validatePSBTFields(version, PSBTInput, i);\n  for (const o of tx.outputs) validatePSBTFields(version, PSBTOutput, o);\n  // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  const inputCount = !version ? tx.global.unsignedTx!.inputs.length : tx.global.inputCount!;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  const inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n    throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n  // Same for inputs\n  const outputCount = !version ? tx.global.unsignedTx!.outputs.length : tx.global.outputCount!;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  const outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n    throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n  return tx;\n}\n\nfunction mergeKeyMap<T extends PSBTKeyMap>(\n  psbtEnum: T,\n  val: PSBTKeyMapKeys<T>,\n  cur?: PSBTKeyMapKeys<T>,\n  allowedFields?: (keyof PSBTKeyMapKeys<T>)[]\n): PSBTKeyMapKeys<T> {\n  const res: PSBTKeyMapKeys<T> = { ...cur, ...val };\n  // All arguments can be provided as hex\n  for (const k in psbtEnum) {\n    const key = k as keyof typeof psbtEnum;\n    const [_, kC, vC] = psbtEnum[key];\n    type _KV = [P.UnwrapCoder<typeof kC>, P.UnwrapCoder<typeof vC>];\n    const cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(`Cannot remove signed field=${k}`);\n      delete res[k];\n    } else if (kC) {\n      const oldKV = (cur && cur[k] ? cur[k] : []) as _KV[];\n      let newKV = val[key] as _KV[];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n        // Decode hex in k-v\n        newKV = newKV.map((val: _KV): _KV => {\n          if (val.length !== 2) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n          return [\n            typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n            typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n          ];\n        });\n        const map: Record<string, _KV> = {};\n        const add = (kStr: string, k: _KV[0], v: _KV[1]) => {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          const oldVal = hex.encode(vC.encode(map[kStr][1]));\n          const newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal)\n            throw new Error(\n              `keyMap(${key as string}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`\n            );\n        };\n        for (const [k, v] of oldKV) {\n          const kStr = hex.encode(kC.encode(k));\n          add(kStr, k, v);\n        }\n        for (const [k, v] of newKV) {\n          const kStr = hex.encode(kC.encode(k));\n          // undefined removes previous value\n          if (v === undefined) {\n            if (cannotChange) throw new Error(`Cannot remove signed field=${key as string}/${k}`);\n            delete map[kStr];\n          } else add(kStr, k, v);\n        }\n        (res as any)[key] = Object.values(map) as _KV[];\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k] as string));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n        throw new Error(`Cannot change signed field=${k}`);\n    }\n  }\n  // Remove unknown keys\n  for (const k in res) if (!psbtEnum[k]) delete res[k];\n  return res;\n}\n\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\n// /Coders\n\n// Payments\n// We need following items:\n// - encode/decode output script\n// - generate input script\n// - generate address/output/redeem from user input\n// P2ret represents generic interface for all p2* methods\nexport type P2Ret = {\n  type: string;\n  script: Bytes;\n  address?: string;\n  redeemScript?: Bytes;\n  witnessScript?: Bytes;\n};\n// Public Key (P2PK)\ntype OutPKType = { type: 'pk'; pubkey: Bytes };\ntype OptScript = ScriptType | undefined;\nconst OutPK: Coder<OptScript, OutPKType | undefined> = {\n  encode(from: ScriptType): OutPKType | undefined {\n    if (\n      from.length !== 2 ||\n      !isBytes(from[0]) ||\n      !isValidPubkey(from[0], PubT.ecdsa) ||\n      from[1] !== 'CHECKSIG'\n    )\n      return;\n    return { type: 'pk', pubkey: from[0] };\n  },\n  decode: (to: OutPKType): OptScript => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n// @ts-ignore\nexport const p2pk = (pubkey: Bytes, network = NETWORK): P2Ret => {\n  // network is unused\n  if (!isValidPubkey(pubkey, PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return {\n    type: 'pk',\n    script: OutScript.encode({ type: 'pk', pubkey }),\n  };\n};\n\n// Public Key Hash (P2PKH)\ntype OutPKHType = { type: 'pkh'; hash: Bytes };\nconst OutPKH: Coder<OptScript, OutPKHType | undefined> = {\n  encode(from: ScriptType): OutPKHType | undefined {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2]))\n      return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return { type: 'pkh', hash: from[2] };\n  },\n  decode: (to: OutPKHType): OptScript =>\n    to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\nexport const p2pkh = (publicKey: Bytes, network = NETWORK): P2Ret => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  const hash = hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({ type: 'pkh', hash }),\n    address: Address(network).encode({ type: 'pkh', hash }),\n  };\n};\n// Script Hash (P2SH)\ntype OutSHType = { type: 'sh'; hash: Bytes };\nconst OutSH: Coder<OptScript, OutSHType | undefined> = {\n  encode(from: ScriptType): OutSHType | undefined {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL')\n      return;\n    return { type: 'sh', hash: from[1] };\n  },\n  decode: (to: OutSHType): OptScript =>\n    to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\nexport const p2sh = (child: P2Ret, network = NETWORK): P2Ret => {\n  // It is already tested inside noble-hashes and checkScript\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n  const hash = hash160(cs);\n  const script = OutScript.encode({ type: 'sh', hash });\n  checkScript(script, cs, child.witnessScript);\n  const res: P2Ret = {\n    type: 'sh',\n    redeemScript: cs,\n    script: OutScript.encode({ type: 'sh', hash }),\n    address: Address(network).encode({ type: 'sh', hash }),\n  };\n  if (child.witnessScript) res.witnessScript = child.witnessScript;\n  return res;\n};\n// Witness Script Hash (P2WSH)\ntype OutWSHType = { type: 'wsh'; hash: Bytes };\nconst OutWSH: Coder<OptScript, OutWSHType | undefined> = {\n  encode(from: ScriptType): OutWSHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return { type: 'wsh', hash: from[1] };\n  },\n  decode: (to: OutWSHType): OptScript => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\nexport const p2wsh = (child: P2Ret, network = NETWORK): P2Ret => {\n  const cs = child.script;\n  if (!isBytes(cs)) throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n  const hash = sha256(cs);\n  const script = OutScript.encode({ type: 'wsh', hash });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({ type: 'wsh', hash }),\n    address: Address(network).encode({ type: 'wsh', hash }),\n  };\n};\n// Witness Public Key Hash (P2WPKH)\ntype OutWPKHType = { type: 'wpkh'; hash: Bytes };\nconst OutWPKH: Coder<OptScript, OutWPKHType | undefined> = {\n  encode(from: ScriptType): OutWPKHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return { type: 'wpkh', hash: from[1] };\n  },\n  decode: (to: OutWPKHType): OptScript => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\nexport const p2wpkh = (publicKey: Bytes, network = NETWORK): P2Ret => {\n  if (!isValidPubkey(publicKey, PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  const hash = hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({ type: 'wpkh', hash }),\n    address: Address(network).encode({ type: 'wpkh', hash }),\n  };\n};\n// Multisig (P2MS)\ntype OutMSType = { type: 'ms'; pubkeys: Bytes[]; m: number };\nconst OutMS: Coder<OptScript, OutMSType | undefined> = {\n  encode(from: ScriptType): OutMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    const m = from[0];\n    const n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    const pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    for (const pub of pubkeys) if (!isBytes(pub)) return;\n    return { type: 'ms', m, pubkeys: pubkeys as Bytes[] }; // we don't need n, since it is the same as pubkeys\n  },\n  // checkmultisig(n, ..pubkeys, m)\n  decode: (to: OutMSType): OptScript =>\n    to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\nexport const p2ms = (m: number, pubkeys: Bytes[], allowSamePubkeys = false): P2Ret => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return { type: 'ms', script: OutScript.encode({ type: 'ms', pubkeys, m }) };\n};\n// Taproot (P2TR)\ntype OutTRType = { type: 'tr'; pubkey: Bytes };\nconst OutTR: Coder<OptScript, OutTRType | undefined> = {\n  encode(from: ScriptType): OutTRType | undefined {\n    if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1])) return;\n    return { type: 'tr', pubkey: from[1] };\n  },\n  decode: (to: OutTRType): OptScript => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\nexport type TaprootNode = {\n  script: Bytes | string;\n  leafVersion?: number;\n  weight?: number;\n} & Partial<P2TROut>;\nexport type TaprootScriptTree = TaprootNode | TaprootScriptTree[];\nexport type TaprootScriptList = TaprootNode[];\ntype _TaprootTreeInternal = {\n  weight?: number;\n  childs?: [_TaprootTreeInternal[], _TaprootTreeInternal[]];\n};\n\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList: TaprootScriptList): TaprootScriptTree {\n  // Clone input in order to not corrupt it\n  const lst = Array.from(taprootList) as _TaprootTreeInternal[];\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n    const b = lst.pop()!;\n    const a = lst.pop()!;\n    const weight = (a?.weight || 1) + (b?.weight || 1);\n    lst.push({\n      weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [a?.childs || (a as any[]), b?.childs || (b as any)],\n    });\n  }\n  // At this point there is always 1 element in lst\n  const last = lst[0];\n  return (last?.childs || last) as TaprootScriptTree;\n}\ntype HashedTree =\n  | { type: 'leaf'; version?: number; script: Bytes; hash: Bytes }\n  | { type: 'branch'; left: HashedTree; right: HashedTree; hash: Bytes };\nfunction checkTaprootScript(script: Bytes, internalPubKey: Bytes, allowUnknownOutputs = false) {\n  const out = OutScript.decode(script);\n  if (out.type === 'unknown' && allowUnknownOutputs) return;\n  if (!['tr_ns', 'tr_ms'].includes(out.type))\n    throw new Error(`P2TR: invalid leaf script=${out.type}`);\n  const outms = out as OutTRNSType | OutTRMSType;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    for (const p of outms.pubkeys) {\n      if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY))\n        throw new Error('Unspendable taproot key in leaf script');\n      // It's likely a mistake at this point:\n      // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n      // but will take more space and fees.\n      // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n      // User creates 2 of 3 multisig of keys [A, B, C],\n      // but key A always can spend whole output without signatures from other keys.\n      // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n      if (P.equalBytes(p, internalPubKey)) {\n        throw new Error(\n          'Using P2TR with leaf script with same key as internal key is not supported'\n        );\n      }\n    }\n  }\n}\nfunction taprootHashTree(\n  tree: TaprootScriptTree,\n  internalPubKey: Bytes,\n  allowUnknownOutputs = false\n): HashedTree {\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    const { leafVersion: version, script: leafScript } = tree;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || (tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n      throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!isBytes(script)) throw new Error(`checkScript: wrong script type=${script}`);\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n    return {\n      type: 'leaf',\n      version,\n      script,\n      hash: tapLeafHash(script, version),\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree as TaprootNode[]) as TaprootNode[];\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n  const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n  // We cannot swap left/right here, since it will change structure of tree\n  let [lH, rH] = [left.hash, right.hash];\n  if (_cmpBytes(rH, lH) === -1) [lH, rH] = [rH, lH];\n  return { type: 'branch', left, right, hash: schnorr.utils.taggedHash('TapBranch', lH, rH) };\n}\ntype TaprootLeaf = {\n  type: 'leaf';\n  version?: number;\n  script: Bytes;\n  hash: Bytes;\n  path: Bytes[];\n};\n\ntype HashedTreeWithPath =\n  | TaprootLeaf\n  | {\n      type: 'branch';\n      left: HashedTreeWithPath;\n      right: HashedTreeWithPath;\n      hash: Bytes;\n      path: Bytes[];\n    };\n\nfunction taprootAddPath(tree: HashedTree, path: Bytes[] = []): HashedTreeWithPath {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return { ...tree, path };\n  if (tree.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${tree}`);\n  return {\n    ...tree,\n    path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n    right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n  };\n}\nfunction taprootWalkTree(tree: HashedTreeWithPath): TaprootLeaf[] {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${tree}`);\n  return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n\nexport type P2TROut = P2Ret & {\n  tweakedPubkey: Uint8Array;\n  tapInternalKey: Uint8Array;\n  tapMerkleRoot?: Uint8Array;\n  tapLeafScript?: TransactionInput['tapLeafScript'];\n  leaves?: TaprootLeaf[];\n};\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(\n  internalPubKey?: Bytes | string,\n  tree?: TaprootScriptTree,\n  network = NETWORK,\n  allowUnknownOutputs = false\n): P2TROut {\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  const pubKey =\n    typeof internalPubKey === 'string'\n      ? hex.decode(internalPubKey)\n      : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  let hashedTree = tree\n    ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs))\n    : undefined;\n  const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n  const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n  let leaves;\n  if (hashedTree) {\n    leaves = taprootWalkTree(hashedTree).map((l) => ({\n      ...l,\n      controlBlock: TaprootControlBlock.encode({\n        version: (l.version || TAP_LEAF_VERSION) + parity,\n        internalKey: pubKey,\n        merklePath: l.path,\n      }),\n    }));\n  }\n  let tapLeafScript: TransactionInput['tapLeafScript'];\n  if (leaves) {\n    tapLeafScript = leaves.map((l) => [\n      TaprootControlBlock.decode(l.controlBlock),\n      concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n    ]);\n  }\n  const res: P2TROut = {\n    type: 'tr',\n    script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n    address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n    // For tests\n    tweakedPubkey,\n    // PSBT stuff\n    tapInternalKey: pubKey,\n  };\n  // Just in case someone would want to select a specific script\n  if (leaves) res.leaves = leaves;\n  if (tapLeafScript) res.tapLeafScript = tapLeafScript;\n  if (tapMerkleRoot) res.tapMerkleRoot = tapMerkleRoot;\n  return res;\n}\n\n// Taproot N-of-N multisig (P2TR_NS)\ntype OutTRNSType = { type: 'tr_ns'; pubkeys: Bytes[] };\nconst OutTRNS: Coder<OptScript, OutTRNSType | undefined> = {\n  encode(from: ScriptType): OutTRNSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    // On error return, since it can be different script\n    for (let i = 0; i < last; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ns', pubkeys };\n  },\n  decode: (to: OutTRNSType): OptScript => {\n    if (to.type !== 'tr_ns') return;\n    const out: ScriptType = [];\n    for (let i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  },\n};\n// Returns all combinations of size M from lst\nexport function combinations<T>(m: number, list: T[]): T[][] {\n  const res: T[][] = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  const n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  const idx = Array.from({ length: m }, (_, i) => i);\n  const last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map((i) => list[i]));\n    idx[last] += 1;\n    let i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m: number, pubkeys: Bytes[], allowSamePubkeys = false): P2Ret[] => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map((i) => ({\n    type: 'tr_ns',\n    script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n  }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = (pubkey: Bytes): P2Ret => p2tr_ns(1, [pubkey], undefined)[0];\n\n// Taproot M-of-N Multisig (P2TR_MS)\ntype OutTRMSType = { type: 'tr_ms'; pubkeys: Bytes[]; m: number };\nconst OutTRMS: Coder<OptScript, OutTRMSType | undefined> = {\n  encode(from: ScriptType): OutTRMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    const m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (let i = 0; i < last - 1; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n          throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ms', pubkeys, m };\n  },\n  decode: (to: OutTRMSType): OptScript => {\n    if (to.type !== 'tr_ms') return;\n    const out: ScriptType = [to.pubkeys[0], 'CHECKSIG'];\n    for (let i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  },\n};\nexport function p2tr_ms(m: number, pubkeys: Bytes[], allowSamePubkeys = false) {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n  };\n}\n// Unknown output type\ntype OutUnknownType = { type: 'unknown'; script: Bytes };\nconst OutUnknown: Coder<OptScript, OutUnknownType | undefined> = {\n  encode(from: ScriptType): OutUnknownType | undefined {\n    return { type: 'unknown', script: Script.encode(from) };\n  },\n  decode: (to: OutUnknownType): OptScript =>\n    to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\n\nconst OutScripts = [\n  OutPK,\n  OutPKH,\n  OutSH,\n  OutWSH,\n  OutWPKH,\n  OutMS,\n  OutTR,\n  OutTRNS,\n  OutTRMS,\n  OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, (i) => {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa))\n    throw new Error('OutScript/pk: wrong key');\n  if (\n    (i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n    (!isBytes(i.hash) || i.hash.length !== 20)\n  )\n    throw new Error(`OutScript/${i.type}: wrong hash`);\n  if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32))\n    throw new Error(`OutScript/wsh: wrong hash`);\n  if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr)))\n    throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n    if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    const n = i.pubkeys.length;\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, PubT.schnorr)) throw new Error(`OutScript/${i.type}: wrong pubkey`);\n  }\n  if (i.type === 'tr_ms') {\n    const n = i.pubkeys.length;\n    if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\n\n// Address\nfunction validateWitness(version: number, data: Bytes) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32))\n    throw new Error('Witness: invalid length for version');\n}\n\nexport function programToWitness(version: number, data: Bytes, network = NETWORK) {\n  validateWitness(version, data);\n  const coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\n\nfunction formatKey(hashed: Bytes, prefix: number[]): string {\n  return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\n\nexport function WIF(network = NETWORK): Coder<Bytes, string> {\n  return {\n    encode(privKey: Bytes) {\n      const compressed = concat(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode(wif: string) {\n      let parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    },\n  };\n}\n\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n  return {\n    encode(from: P.UnwrapCoder<typeof OutScript>): string {\n      const { type } = from;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);\n      else if (type === 'wsh') return programToWitness(0, from.hash, network);\n      else if (type === 'tr') return programToWitness(1, from.pubkey, network);\n      else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);\n      else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(`Unknown address type=${type}`);\n    },\n    decode(address: string): P.UnwrapCoder<typeof OutScript> {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n        let res;\n        try {\n          res = bech32.decode(address);\n          if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`);\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address);\n          if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`);\n        }\n        if (res.prefix !== network.bech32) throw new Error(`wrong bech32 prefix=${res.prefix}`);\n        const [version, ...program] = res.words;\n        const data = bech32.fromWords(program);\n        validateWitness(version, data);\n        if (version === 0 && data.length === 32) return { type: 'wsh', hash: data };\n        else if (version === 0 && data.length === 20) return { type: 'wpkh', hash: data };\n        else if (version === 1 && data.length === 32) return { type: 'tr', pubkey: data };\n        else throw new Error('Unknown witness program');\n      }\n      const data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return { type: 'pkh', hash: data.slice(1) };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1),\n        };\n      }\n      throw new Error(`Invalid address prefix=${data[0]}`);\n    },\n  };\n}\n// /Address\n\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport enum SignatureHash {\n  DEFAULT,\n  ALL,\n  NONE,\n  SINGLE,\n  ANYONECANPAY = 0x80,\n}\n\nexport enum SigHash {\n  DEFAULT = SignatureHash.DEFAULT,\n  ALL = SignatureHash.ALL,\n  NONE = SignatureHash.NONE,\n  SINGLE = SignatureHash.SINGLE,\n  DEFAULT_ANYONECANPAY = SignatureHash.DEFAULT | SignatureHash.ANYONECANPAY,\n  ALL_ANYONECANPAY = SignatureHash.ALL | SignatureHash.ANYONECANPAY,\n  NONE_ANYONECANPAY = SignatureHash.NONE | SignatureHash.ANYONECANPAY,\n  SINGLE_ANYONECANPAY = SignatureHash.SINGLE | SignatureHash.ANYONECANPAY,\n}\n\nfunction validateSigHash(s: SigHash) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n    throw new Error(`Invalid SigHash=${s}`);\n  return s;\n}\n\nfunction unpackSighash(hashType: number) {\n  const masked = hashType & 0b0011111;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE,\n  };\n}\n\nexport const _sortPubkeys = (pubkeys: Bytes[]) => Array.from(pubkeys).sort(_cmpBytes);\n\nexport type TransactionInput = P.UnwrapCoder<typeof PSBTInputCoder>;\n// User facing API with decoders\nexport type TransactionInputUpdate = ExtendType<\n  TransactionInput,\n  {\n    nonWitnessUtxo?: string | Bytes;\n    txid?: string;\n  }\n>;\nexport type TransactionInputRequired = {\n  txid: Bytes;\n  index: number;\n  sequence: number;\n  finalScriptSig: Bytes;\n};\n// Force check index/txid/sequence\nfunction inputBeforeSign(i: TransactionInput): TransactionInputRequired {\n  if (i.txid === undefined || i.index === undefined)\n    throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n  };\n}\nfunction cleanFinalInput(i: TransactionInput) {\n  for (const _k in i) {\n    const k = _k as keyof TransactionInput;\n    if (!PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n\nexport type TransactionOutput = P.UnwrapCoder<typeof PSBTOutputCoder>;\nexport type TransactionOutputUpdate = ExtendType<TransactionOutput, { script?: string }>;\nexport type TransactionOutputRequired = {\n  script: Bytes;\n  amount: bigint;\n};\n// Force check amount/script\nfunction outputBeforeSign(i: TransactionOutput): TransactionOutputRequired {\n  if (i.script === undefined || i.amount === undefined)\n    throw new Error('Transaction/output: script and amount required');\n  return { script: i.script, amount: i.amount };\n}\n\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script: Bytes, version = TAP_LEAF_VERSION) =>\n  schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\n\nfunction getTaprootKeys(\n  privKey: Bytes,\n  pubKey: Bytes,\n  internalKey: Bytes,\n  merkleRoot: Bytes = P.EMPTY\n) {\n  if (P.equalBytes(internalKey, pubKey)) {\n    privKey = taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = schnorr.getPublicKey(privKey);\n  }\n  return { privKey, pubKey };\n}\n\n// @scure/bip32 interface\ninterface HDKey {\n  publicKey: Bytes;\n  privateKey: Bytes;\n  fingerprint: number;\n  derive(path: string): HDKey;\n  deriveChild(index: number): HDKey;\n  sign(hash: Bytes): Bytes;\n}\n\nexport type Signer = Bytes | HDKey;\n\n// Mostly security features, hardened defaults;\n// but you still can parse other people tx with unspendable outputs and stuff if you want\nexport type TxOpts = {\n  version?: number;\n  lockTime?: number;\n  PSBTVersion?: number;\n  // Flags\n  // Allow output scripts to be unknown scripts (probably unspendable)\n  /** @deprecated Use `allowUnknownOutputs` */\n  allowUnknowOutput?: boolean;\n  allowUnknownOutputs?: boolean;\n  // Try to sign/finalize unknown input. All bets are off, but there is chance that it will work\n  /** @deprecated Use `allowUnknownInputs` */\n  allowUnknowInput?: boolean;\n  allowUnknownInputs?: boolean;\n  // Check input/output scripts for sanity\n  disableScriptCheck?: boolean;\n  // There is strange behaviour where tx without outputs encoded with empty output in the end,\n  // tx without outputs in BIP174 doesn't have itb\n  bip174jsCompat?: boolean;\n  // If transaction data comes from untrusted source, then it can be modified in such way that will\n  // result paying higher mining fee\n  allowLegacyWitnessUtxo?: boolean;\n  lowR?: boolean; // Use lowR signatures\n};\n\nconst toStr = {}.toString;\nfunction validateOpts(opts: TxOpts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error(`Wrong object type for transaction options: ${opts}`);\n\n  const _opts = {\n    ...opts,\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0),\n  };\n  if (typeof _opts.allowUnknowInput !== 'undefined')\n    opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined')\n    opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  // 0 and -1 happens in tests\n  if (![-1, 0, 1, 2].includes(_opts.version)) throw new Error(`Unknown version: ${_opts.version}`);\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n    throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n  // Flags\n  for (const k of [\n    'allowUnknownOutputs',\n    'allowUnknownInputs',\n    'disableScriptCheck',\n    'bip174jsCompat',\n    'allowLegacyWitnessUtxo',\n    'lowR',\n  ] as const) {\n    const v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean')\n      throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n  }\n  return Object.freeze(_opts);\n}\n\nexport class Transaction {\n  private global: PSBTKeyMapKeys<typeof PSBTGlobal> = {};\n  private inputs: TransactionInput[] = []; // use getInput()\n  private outputs: TransactionOutput[] = []; // use getOutput()\n  readonly opts: ReturnType<typeof validateOpts>;\n  constructor(opts: TxOpts = {}) {\n    const _opts = (this.opts = validateOpts(opts));\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n\n  // Import\n  static fromRaw(raw: Bytes, opts: TxOpts = {}) {\n    const parsed = RawTx.decode(raw);\n    const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n    for (const o of parsed.outputs) tx.addOutput(o);\n    tx.outputs = parsed.outputs;\n    tx.inputs = parsed.inputs;\n    if (parsed.witnesses) {\n      for (let i = 0; i < parsed.witnesses.length; i++)\n        tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n    }\n    return tx;\n  }\n  // PSBT\n  static fromPSBT(psbt: Bytes, opts: TxOpts = {}) {\n    let parsed: P.UnwrapCoder<typeof RawPSBTV0>;\n    try {\n      parsed = RawPSBTV0.decode(psbt);\n    } catch (e0) {\n      try {\n        parsed = RawPSBTV2.decode(psbt);\n      } catch (e2) {\n        // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n        throw e0;\n      }\n    }\n    const PSBTVersion = parsed.global.version || 0;\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const unsigned = parsed.global.unsignedTx;\n    const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n    const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n    const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n    // We need slice here, because otherwise\n    const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n    tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n      finalScriptSig: P.EMPTY,\n      ...parsed.global.unsignedTx?.inputs[j],\n      ...i,\n    }));\n    const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n    tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n      ...i,\n      ...parsed.global.unsignedTx?.outputs[j],\n    }));\n    tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n    if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n    return tx;\n  }\n  toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const inputs = this.inputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n    for (const inp of inputs) {\n      // Don't serialize empty fields\n      if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n      if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n      if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n    }\n    const outputs = this.outputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n    const global = { ...this.global };\n    if (PSBTVersion === 0) {\n      global.unsignedTx = RawTx.decode(this.unsignedTx);\n      delete global.fallbackLocktime;\n      delete global.txVersion;\n    } else {\n      global.version = PSBTVersion;\n      global.txVersion = this.version;\n      global.inputCount = this.inputs.length;\n      global.outputCount = this.outputs.length;\n      if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n        delete global.fallbackLocktime;\n    }\n    if (this.opts.bip174jsCompat) {\n      if (!inputs.length) inputs.push({});\n      if (!outputs.length) outputs.push({});\n    }\n    return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n      global,\n      inputs,\n      outputs,\n    });\n  }\n\n  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  get lockTime() {\n    let height = DEFAULT_LOCKTIME;\n    let heightCnt = 0;\n    let time = DEFAULT_LOCKTIME;\n    let timeCnt = 0;\n    for (const i of this.inputs) {\n      if (i.requiredHeightLocktime) {\n        height = Math.max(height, i.requiredHeightLocktime);\n        heightCnt++;\n      }\n      if (i.requiredTimeLocktime) {\n        time = Math.max(time, i.requiredTimeLocktime);\n        timeCnt++;\n      }\n    }\n    if (heightCnt && heightCnt >= timeCnt) return height;\n    if (time !== DEFAULT_LOCKTIME) return time;\n    return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n  }\n\n  get version() {\n    // Should be not possible\n    if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n    return this.global.txVersion;\n  }\n\n  private inputStatus(idx: number) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    // Finalized\n    if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n    if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n    // Signed taproot\n    if (input.tapKeySig) return 'signed';\n    if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n    // Signed\n    if (input.partialSig && input.partialSig.length) return 'signed';\n    return 'unsigned';\n  }\n  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n  // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  private inputSighash(idx: number) {\n    this.checkInputIdx(idx);\n    const sighash = this.inputType(this.inputs[idx]).sighash;\n    // ALL or DEFAULT -- everything signed\n    // NONE           -- all inputs + no outputs\n    // SINGLE         -- all inputs + output with same index\n    // ALL + ANYONE   -- specific input + all outputs\n    // NONE + ANYONE  -- specific input + no outputs\n    // SINGLE         -- specific inputs + output with same index\n    const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n    const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n    return { sigInputs, sigOutputs };\n  }\n  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n  // Some cache will be nice, but there chance to have bugs with cache invalidation\n  private signStatus() {\n    // if addInput or addOutput is not possible, then all inputs or outputs are signed\n    let addInput = true,\n      addOutput = true;\n    let inputs = [],\n      outputs = [];\n    for (let idx = 0; idx < this.inputs.length; idx++) {\n      const status = this.inputStatus(idx);\n      // Unsigned input doesn't affect anything\n      if (status === 'unsigned') continue;\n      const { sigInputs, sigOutputs } = this.inputSighash(idx);\n      // Input type\n      if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);\n      else addInput = false;\n      // Output type\n      if (sigOutputs === SignatureHash.ALL) addOutput = false;\n      else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);\n      else if (sigOutputs === SignatureHash.NONE) {\n        // Doesn't affect any outputs at all\n      } else throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n    }\n    return { addInput, addOutput, inputs, outputs };\n  }\n\n  get isFinal() {\n    for (let idx = 0; idx < this.inputs.length; idx++)\n      if (this.inputStatus(idx) !== 'finalized') return false;\n    return true;\n  }\n\n  // Info utils\n  get hasWitnesses(): boolean {\n    let out = false;\n    for (const i of this.inputs)\n      if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n    return out;\n  }\n  // https://en.bitcoin.it/wiki/Weight_units\n  get weight(): number {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    // TODO: Can we find out how much witnesses/script will be used before signing?\n    let out = 32;\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (this.hasWitnesses) out += 2;\n    out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n    out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n    for (const i of this.inputs)\n      out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n    for (const o of outputs) out += 32 + 4 * VarBytes.encode(o.script).length;\n    if (this.hasWitnesses) {\n      for (const i of this.inputs)\n        if (i.finalScriptWitness) out += RawWitness.encode(i.finalScriptWitness).length;\n    }\n    return out;\n  }\n  get vsize(): number {\n    return Math.ceil(this.weight / 4);\n  }\n  toBytes(withScriptSig = false, withWitness = false) {\n    return RawTx.encode({\n      version: this.version,\n      lockTime: this.lockTime,\n      inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n        ...i,\n        finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n      })),\n      outputs: this.outputs.map(outputBeforeSign),\n      witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n      segwitFlag: withWitness && this.hasWitnesses,\n    });\n  }\n  get unsignedTx(): Bytes {\n    return this.toBytes(false, false);\n  }\n  get hex() {\n    return hex.encode(this.toBytes(true, this.hasWitnesses));\n  }\n\n  get hash() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)));\n  }\n  get id() {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(sha256x2(this.toBytes(true)).reverse());\n  }\n  // Input stuff\n  private checkInputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n      throw new Error(`Wrong input index=${idx}`);\n  }\n  getInput(idx: number) {\n    this.checkInputIdx(idx);\n    return cloneDeep(this.inputs[idx]);\n  }\n  get inputsLength() {\n    return this.inputs.length;\n  }\n  // Modification\n  private normalizeInput(\n    i: TransactionInputUpdate,\n    cur?: TransactionInput,\n    allowedFields?: (keyof TransactionInput)[]\n  ): TransactionInput {\n    let { nonWitnessUtxo, txid } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors (like hex looking string accidentally passed),\n    // however in case of nonWitnessUtxo it is better to expect string, since constructing this complex object will be difficult for user\n    if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n    if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n    if (nonWitnessUtxo === undefined) nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string') txid = hex.decode(txid);\n    if (txid === undefined) txid = cur?.txid;\n    let res: PSBTKeyMapKeys<typeof PSBTInput> = { ...cur, ...i, nonWitnessUtxo, txid };\n    if (res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n    if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n    res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n    PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined)\n      prevOut = res.nonWitnessUtxo.outputs[res.index];\n    else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n    if (prevOut && !this.opts.disableScriptCheck)\n      checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n\n    return res;\n  }\n  addInput(input: TransactionInputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addInput)\n      throw new Error('Tx has signed inputs, cannot add new one');\n    this.inputs.push(this.normalizeInput(input));\n    return this.inputs.length - 1;\n  }\n  updateInput(idx: number, input: TransactionInputUpdate, _ignoreSignStatus = false) {\n    this.checkInputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addInput || status.inputs.includes(idx)) allowedFields = PSBTInputUnsignedKeys;\n    }\n    this.inputs[idx] = this.normalizeInput(input, this.inputs[idx], allowedFields);\n  }\n  // Output stuff\n  private checkOutputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n      throw new Error(`Wrong output index=${idx}`);\n  }\n  getOutput(idx: number) {\n    this.checkOutputIdx(idx);\n    return cloneDeep(this.outputs[idx]);\n  }\n  get outputsLength() {\n    return this.outputs.length;\n  }\n  private normalizeOutput(\n    o: TransactionOutputUpdate,\n    cur?: TransactionOutput,\n    allowedFields?: (keyof typeof PSBTOutput)[]\n  ): TransactionOutput {\n    let { amount, script } = o;\n    if (amount === undefined) amount = cur?.amount;\n    if (typeof amount !== 'bigint') throw new Error('amount must be bigint sats');\n    if (typeof script === 'string') script = hex.decode(script);\n    if (script === undefined) script = cur?.script;\n    let res: PSBTKeyMapKeys<typeof PSBTOutput> = { ...cur, ...o, amount, script };\n    if (res.amount === undefined) delete res.amount;\n    res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n    PSBTOutputCoder.encode(res);\n    if (\n      res.script &&\n      !this.opts.allowUnknownOutputs &&\n      OutScript.decode(res.script).type === 'unknown'\n    ) {\n      throw new Error(\n        'Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure'\n      );\n    }\n    if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addOutput(o: TransactionOutputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addOutput)\n      throw new Error('Tx has signed outputs, cannot add new one');\n    this.outputs.push(this.normalizeOutput(o));\n    return this.outputs.length - 1;\n  }\n  updateOutput(idx: number, output: TransactionOutputUpdate, _ignoreSignStatus = false) {\n    this.checkOutputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addOutput || status.outputs.includes(idx)) allowedFields = PSBTOutputUnsignedKeys;\n    }\n    this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n  }\n  addOutputAddress(address: string, amount: bigint, network = NETWORK): number {\n    return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n  }\n  // Utils\n  get fee(): bigint {\n    let res = 0n;\n    for (const i of this.inputs) {\n      const prevOut = this.prevOut(i);\n      if (!prevOut) throw new Error('Empty input amount');\n      res += prevOut.amount;\n    }\n    const outputs = this.outputs.map(outputBeforeSign);\n    for (const o of outputs) res -= o.amount;\n    return res;\n  }\n\n  // Signing\n  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n  // but we are trying to be less complicated for audit purpose for now.\n  private preimageLegacy(idx: number, prevOutScript: Bytes, hashType: number) {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(`Invalid input idx=${idx}`);\n    if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n      return P.U256BE.encode(1n);\n    prevOutScript = Script.encode(\n      Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR')\n    );\n    let inputs: TransactionInputRequired[] = this.inputs\n      .map(inputBeforeSign)\n      .map((input, inputIdx) => ({\n        ...input,\n        finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n      }));\n    if (isAny) inputs = [inputs[idx]];\n    else if (isNone || isSingle) {\n      inputs = inputs.map((input, inputIdx) => ({\n        ...input,\n        sequence: inputIdx === idx ? input.sequence : 0,\n      }));\n    }\n    let outputs = this.outputs.map(outputBeforeSign);\n    if (isNone) outputs = [];\n    else if (isSingle) {\n      outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n    }\n    const tmpTx = RawTx.encode({\n      lockTime: this.lockTime,\n      version: this.version,\n      segwitFlag: false,\n      inputs,\n      outputs,\n    });\n    return sha256x2(tmpTx, P.I32LE.encode(hashType));\n  }\n  private preimageWitnessV0(idx: number, prevOutScript: Bytes, hashType: number, amount: bigint) {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    let inputHash = EMPTY32;\n    let sequenceHash = EMPTY32;\n    let outputHash = EMPTY32;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (!isAny) inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n    if (!isAny && !isSingle && !isNone)\n      sequenceHash = sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n    if (!isSingle && !isNone) {\n      outputHash = sha256x2(...outputs.map(RawOutput.encode));\n    } else if (isSingle && idx < outputs.length)\n      outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n    const input = inputs[idx];\n    return sha256x2(\n      P.I32LE.encode(this.version),\n      inputHash,\n      sequenceHash,\n      P.bytes(32, true).encode(input.txid),\n      P.U32LE.encode(input.index),\n      VarBytes.encode(prevOutScript),\n      P.U64LE.encode(amount),\n      P.U32LE.encode(input.sequence),\n      outputHash,\n      P.U32LE.encode(this.lockTime),\n      P.U32LE.encode(hashType)\n    );\n  }\n  private preimageWitnessV1(\n    idx: number,\n    prevOutScript: Bytes[],\n    hashType: number,\n    amount: bigint[],\n    codeSeparator = -1,\n    leafScript?: Bytes,\n    leafVer = 0xc0,\n    annex?: Bytes\n  ) {\n    if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n      throw new Error(`Invalid amounts array=${amount}`);\n    if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n      throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n    const out: Bytes[] = [\n      P.U8.encode(0),\n      P.U8.encode(hashType), // U8 sigHash\n      P.I32LE.encode(this.version),\n      P.U32LE.encode(this.lockTime),\n    ];\n    const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n    const inType = hashType & SignatureHash.ANYONECANPAY;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (inType !== SignatureHash.ANYONECANPAY) {\n      out.push(\n        ...[\n          inputs.map(TxHashIdx.encode),\n          amount.map(P.U64LE.encode),\n          prevOutScript.map(VarBytes.encode),\n          inputs.map((i) => P.U32LE.encode(i.sequence)),\n        ].map((i) => sha256(concat(...i)))\n      );\n    }\n    if (outType === SignatureHash.ALL) {\n      out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n    }\n    const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n    out.push(new Uint8Array([spendType]));\n    if (inType === SignatureHash.ANYONECANPAY) {\n      const inp = inputs[idx];\n      out.push(\n        TxHashIdx.encode(inp),\n        P.U64LE.encode(amount[idx]),\n        VarBytes.encode(prevOutScript[idx]),\n        P.U32LE.encode(inp.sequence)\n      );\n    } else out.push(P.U32LE.encode(idx));\n    if (spendType & 1) out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n    if (outType === SignatureHash.SINGLE)\n      out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n    if (leafScript)\n      out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n    return schnorr.utils.taggedHash('TapSighash', ...out);\n  }\n  // Utils for sign/finalize\n  // Used pretty often, should be fast\n  private prevOut(input: TransactionInput): P.UnwrapCoder<typeof RawOutput> {\n    if (input.nonWitnessUtxo) {\n      if (input.index === undefined) throw new Error('Unknown input index');\n      return input.nonWitnessUtxo.outputs[input.index];\n    } else if (input.witnessUtxo) return input.witnessUtxo;\n    else throw new Error('Cannot find previous output info');\n  }\n  private inputType(input: TransactionInput) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = this.prevOut(input);\n    const first = OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n      defaultSighash = SignatureHash.DEFAULT;\n      return {\n        txType: 'taproot',\n        type: 'tr',\n        last: first,\n        lastScript: prevOut.script,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash,\n      };\n    } else {\n      if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n      if (first.type === 'sh') {\n        if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n        let child = OutScript.decode(input.redeemScript);\n        if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      // wsh can be inside sh\n      if (cur.type === 'wsh') {\n        if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n        let child = OutScript.decode(input.witnessScript);\n        if (child.type === 'wsh') txType = 'segwit';\n        stack.push(child);\n        cur = child;\n        type += `-${child.type}`;\n      }\n      const last = stack[stack.length - 1];\n      if (last.type === 'sh' || last.type === 'wsh')\n        throw new Error('inputType: sh/wsh cannot be terminal type');\n      const lastScript = OutScript.encode(last);\n      const res = {\n        type,\n        txType,\n        last,\n        lastScript,\n        defaultSighash,\n        sighash: input.sighashType || defaultSighash,\n      };\n      if (txType === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n        throw new Error(\n          `Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`\n        );\n      }\n      return res;\n    }\n  }\n\n  // Signer can be privateKey OR instance of bip32 HD stuff\n  signIdx(privateKey: Signer, idx: number, allowedSighash?: SigHash[], _auxRand?: Bytes): boolean {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Handle BIP32 HDKey\n    if (!isBytes(privateKey)) {\n      if (!input.bip32Derivation || !input.bip32Derivation.length)\n        throw new Error('bip32Derivation: empty');\n      const signers = input.bip32Derivation\n        .filter((i) => i[1].fingerprint == (privateKey as HDKey).fingerprint)\n        .map(([pubKey, { path }]) => {\n          let s = privateKey as HDKey;\n          for (const i of path) s = s.deriveChild(i);\n          if (!P.equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n          if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n          return s;\n        });\n      if (!signers.length)\n        throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n      let signed = false;\n      for (const s of signers) if (this.signIdx(s.privateKey, idx)) signed = true;\n      return signed;\n    }\n    // Sighash checks\n    // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n    if (!allowedSighash) allowedSighash = [inputType.defaultSighash as unknown as SigHash];\n    else allowedSighash.forEach(validateSigHash);\n    const sighash = inputType.sighash;\n    if (!allowedSighash.includes(sighash)) {\n      throw new Error(\n        `Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`\n      );\n    }\n    // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n    // however this was because of bug in bitcoin-core, which remains here because of consensus.\n    // If this is absolutely neccessary for your case, please open issue.\n    // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n    const { sigOutputs } = this.inputSighash(idx);\n    if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n      throw new Error(\n        `Input with sighash SINGLE, but there is no output with corresponding index=${idx}`\n      );\n    }\n\n    // Actual signing\n    // Taproot\n    const prevOut = this.prevOut(input);\n    if (inputType.txType === 'taproot') {\n      if (input.tapBip32Derivation) throw new Error('tapBip32Derivation unsupported');\n      const prevOuts = this.inputs.map(this.prevOut);\n      const prevOutScript = prevOuts.map((i) => i.script);\n      const amount = prevOuts.map((i) => i.amount);\n      let signed = false;\n      let schnorrPub = schnorr.getPublicKey(privateKey);\n      let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n      if (input.tapInternalKey) {\n        // internal + tweak = tweaked key\n        // if internal key == current public key, we need to tweak private key,\n        // otherwise sign as is. bitcoinjs implementation always wants tweaked\n        // priv key to be provided\n        const { pubKey, privKey } = getTaprootKeys(\n          privateKey,\n          schnorrPub,\n          input.tapInternalKey,\n          merkleRoot\n        );\n        const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n        if (P.equalBytes(taprootPubKey, pubKey)) {\n          const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n          const sig = concat(\n            schnorr.sign(hash, privKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(idx, { tapKeySig: sig }, true);\n          signed = true;\n        }\n      }\n      if (input.tapLeafScript) {\n        input.tapScriptSig = input.tapScriptSig || [];\n        for (const [_, _script] of input.tapLeafScript) {\n          const script = _script.subarray(0, -1);\n          const scriptDecoded = Script.decode(script);\n          const ver = _script[_script.length - 1];\n          const hash = tapLeafHash(script, ver);\n          // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n          const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, schnorrPub));\n          // Skip if there is no public key in tapLeafScript\n          if (pos === -1) continue;\n          const msg = this.preimageWitnessV1(\n            idx,\n            prevOutScript,\n            sighash,\n            amount,\n            undefined,\n            script,\n            ver\n          );\n          const sig = concat(\n            schnorr.sign(msg, privateKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(\n            idx,\n            { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] },\n            true\n          );\n          signed = true;\n        }\n      }\n      if (!signed) throw new Error('No taproot scripts signed');\n      return true;\n    } else {\n      // only compressed keys are supported for now\n      const pubKey = _pubECDSA(privateKey);\n      // TODO: replace with explicit checks\n      // Check if script has public key or its has inside\n      let hasPubkey = false;\n      const pubKeyHash = hash160(pubKey);\n      for (const i of Script.decode(inputType.lastScript)) {\n        if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash)))\n          hasPubkey = true;\n      }\n      if (!hasPubkey) throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n      let hash;\n      if (inputType.txType === 'legacy') {\n        hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n      } else if (inputType.txType === 'segwit') {\n        let script = inputType.lastScript;\n        // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n        if (inputType.last.type === 'wpkh')\n          script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n        hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n      } else throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n      const sig = signECDSA(hash, privateKey, this.opts.lowR);\n      this.updateInput(\n        idx,\n        {\n          partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]],\n        },\n        true\n      );\n    }\n    return true;\n  }\n  // This is bad API. Will work if user creates and signs tx, but if\n  // there is some complex workflow with exchanging PSBT and signing them,\n  // then it is better to validate which output user signs. How could a better API look like?\n  // Example: user adds input, sends to another party, then signs received input (mixer etc),\n  // another user can add different input for same key and user will sign it.\n  // Even worse: another user can add bip32 derivation, and spend money from different address.\n  // Better api: signIdx\n  sign(privateKey: Signer, allowedSighash?: number[], _auxRand?: Bytes): number {\n    let num = 0;\n    for (let i = 0; i < this.inputs.length; i++) {\n      try {\n        if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n      } catch (e) {}\n    }\n    if (!num) throw new Error('No inputs signed');\n    return num;\n  }\n\n  finalizeIdx(idx: number) {\n    this.checkInputIdx(idx);\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    const input = this.inputs[idx];\n    const inputType = this.inputType(input);\n    // Taproot finalize\n    if (inputType.txType === 'taproot') {\n      if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];\n      else if (input.tapLeafScript && input.tapScriptSig) {\n        // Sort leafs by control block length.\n        const leafs = input.tapLeafScript.sort(\n          (a, b) =>\n            TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length\n        );\n        for (const [cb, _script] of leafs) {\n          // Last byte is version\n          const script = _script.slice(0, -1);\n          const ver = _script[_script.length - 1];\n          const outScript = OutScript.decode(script);\n          const hash = tapLeafHash(script, ver);\n          const scriptSig = input.tapScriptSig.filter((i) => P.equalBytes(i[0].leafHash, hash));\n          let signatures: Bytes[] = [];\n          if (outScript.type === 'tr_ms') {\n            const m = outScript.m;\n            const pubkeys = outScript.pubkeys;\n            let added = 0;\n            for (const pub of pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n              // Should have exact amount of signatures (more -- will fail)\n              if (added === m || sigIdx === -1) {\n                signatures.push(P.EMPTY);\n                continue;\n              }\n              signatures.push(scriptSig[sigIdx][1]);\n              added++;\n            }\n            // Should be exact same as m\n            if (added !== m) continue;\n          } else if (outScript.type === 'tr_ns') {\n            for (const pub of outScript.pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n              if (sigIdx === -1) continue;\n              signatures.push(scriptSig[sigIdx][1]);\n            }\n            if (signatures.length !== outScript.pubkeys.length) continue;\n          } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n            // Trying our best to sign what we can\n            const scriptDecoded = Script.decode(script);\n            signatures = scriptSig\n              .map(([{ pubKey }, signature]) => {\n                const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, pubKey));\n                if (pos === -1)\n                  throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                return { signature, pos };\n              })\n              // Reverse order (because witness is stack and we take last element first from it)\n              .sort((a, b) => a.pos - b.pos)\n              .map((i) => i.signature);\n            if (!signatures.length) continue;\n          } else throw new Error('Finalize: Unknown tapLeafScript');\n          // Witness is stack, so last element will be used first\n          input.finalScriptWitness = signatures\n            .reverse()\n            .concat([script, TaprootControlBlock.encode(cb)]);\n          break;\n        }\n        if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n      } else throw new Error('finalize/taproot: unknown input');\n      input.finalScriptSig = P.EMPTY;\n      cleanFinalInput(input);\n      return;\n    }\n    if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n\n    let inputScript: Bytes = P.EMPTY;\n    let witness: Bytes[] = [];\n    // TODO: move input scripts closer to payments/output scripts\n    // Multisig\n    if (inputType.last.type === 'ms') {\n      const m = inputType.last.m;\n      const pubkeys = inputType.last.pubkeys;\n      let signatures = [];\n      // partial: [pubkey, sign]\n      for (const pub of pubkeys) {\n        const sign = input.partialSig.find((s) => P.equalBytes(pub, s[0]));\n        if (!sign) continue;\n        signatures.push(sign[1]);\n      }\n      signatures = signatures.slice(0, m);\n      if (signatures.length !== m) {\n        throw new Error(\n          `Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`\n        );\n      }\n      inputScript = Script.encode([0, ...signatures]);\n    } else if (inputType.last.type === 'pk') {\n      inputScript = Script.encode([input.partialSig[0][1]]);\n    } else if (inputType.last.type === 'pkh') {\n      inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n    } else if (inputType.last.type === 'wpkh') {\n      inputScript = P.EMPTY;\n      witness = [input.partialSig[0][1], input.partialSig[0][0]];\n    } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n      throw new Error('Unknown inputs not allowed');\n\n    // Create final scripts (generic part)\n    let finalScriptSig: Bytes | undefined, finalScriptWitness: Bytes[] | undefined;\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        witness = Script.decode(inputScript).map((i) => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      witness = witness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') finalScriptWitness = witness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {\n    } else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n\n    if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n    if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n    if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n    cleanFinalInput(input);\n  }\n  finalize() {\n    for (let i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n  }\n  extract() {\n    if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n    if (!this.outputs.length) throw new Error('Transaction has no outputs');\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    return this.toBytes(true, true);\n  }\n  combine(other: Transaction): this {\n    for (const k of ['PSBTVersion', 'version', 'lockTime'] as const) {\n      if (this.opts[k] !== other.opts[k]) {\n        throw new Error(\n          `Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`\n        );\n      }\n    }\n    for (const k of ['inputs', 'outputs'] as const) {\n      if (this[k].length !== other[k].length) {\n        throw new Error(\n          `Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`\n        );\n      }\n    }\n    const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n    const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n    if (!P.equalBytes(thisUnsigned, otherUnsigned))\n      throw new Error(`Transaction/combine: different unsigned tx`);\n    this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n    for (let i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n    for (let i = 0; i < this.outputs.length; i++) this.updateOutput(i, other.outputs[i], true);\n    return this;\n  }\n  clone() {\n    // deepClone probably faster, but this enforces that encoding is valid\n    return Transaction.fromPSBT(this.toPSBT(2), this.opts);\n  }\n}\n// User facing API?\n\n// Simple pubkey address, without complex scripts\nexport function getAddress(type: 'pkh' | 'wpkh' | 'tr', privKey: Bytes, network = NETWORK) {\n  if (type === 'tr') {\n    return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n  }\n  const pubKey = _pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(`getAddress: unknown type=${type}`);\n}\n\nexport function multisig(m: number, pubkeys: Bytes[], sorted = false, witness = false) {\n  const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms) : p2sh(ms);\n}\n\nexport function sortedMultisig(m: number, pubkeys: Bytes[], witness = false) {\n  return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET: number = 0x80000000;\nexport function bip32Path(path: string): number[] {\n  const out: number[] = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  const parts = path.replace(/^[mM]'?\\//, '').split('/');\n  for (const c of parts) {\n    const m = /^(\\d+)('?)$/.exec(c);\n    if (!m || m.length !== 3) throw new Error(`Invalid child index: ${c}`);\n    let idx = +m[1];\n    if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n    // hardened key\n    if (m[2] === \"'\") idx += HARDENED_OFFSET;\n    out.push(idx);\n  }\n  return out;\n}\n\nexport function PSBTCombine(psbts: Bytes[]): Bytes {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length)\n    throw new Error('PSBTCombine: wrong PSBT list');\n  const tx = Transaction.fromPSBT(psbts[0]);\n  for (let i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}