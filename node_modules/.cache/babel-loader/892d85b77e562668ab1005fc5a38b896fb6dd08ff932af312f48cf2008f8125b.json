{"ast":null,"code":"/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a, b) => c => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, undefined);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, undefined);\n  return {\n    encode,\n    decode\n  };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!rounded) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */(a, b) => !b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */(from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const mask = 2 ** to - 1;\n  const res = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args) {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nexport const utils = {\n  alphabet,\n  chain,\n  checksum,\n  radix,\n  radix2,\n  join,\n  padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n  encode(data) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode(str) {\n    let res = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nexport const base58check = /* @__PURE__ */sha256 => chain(checksum(4, data => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words, limit = 90) {\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n  }\n  function decode(str, limit = 90) {\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    str = lowered;\n    const sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = str.slice(0, sepIndex);\n    const _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n  const decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode,\n    decode,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\nexport const bech32 = /* @__PURE__ */genBech32('bech32');\nexport const bech32m = /* @__PURE__ */genBech32('bech32m');\nexport const utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nexport const hex = /* @__PURE__ */chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n  utf8,\n  hex,\n  base16,\n  base32,\n  base64,\n  base64url,\n  base58,\n  base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;","map":{"version":3,"names":["assertNumber","n","Number","isSafeInteger","Error","chain","args","wrap","a","b","c","encode","Array","from","reverse","reduce","acc","i","undefined","decode","alphabet","digits","isArray","length","map","input","letter","index","indexOf","join","separator","to","split","padding","bits","chr","data","push","end","slice","normalize","fn","convertRadix","pos","res","forEach","d","carry","done","digit","digitBase","rounded","Math","floor","gcd","radix2carry","convertRadix2","mask","radix","num","bytes","Uint8Array","radix2","revPadding","unsafeWrapper","apply","e","checksum","len","set","payload","newChecksum","oldChecksum","utils","base16","base32","base32hex","base32crockford","s","toUpperCase","replace","base64","base64url","base64urlnopad","genBase58","abc","base58","base58flickr","base58xrp","XMR_BLOCK_LEN","base58xmr","block","subarray","padStart","str","blockLen","j","concat","base58check","sha256","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","actualLength","TypeError","lowered","toLowerCase","sum","sepIndex","lastIndexOf","endsWith","decodeUnsafe","decodeToBytes","bech32","bech32m","utf8","TextDecoder","TextEncoder","hex","CODERS","coderTypeError","bytesToString","type","hasOwnProperty","stringToBytes"],"sources":["/Volumes/Data/sats-connect-example-main/node_modules/@scure/base/lib/esm/index.js"],"sourcesContent":["/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexport const utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const base58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}