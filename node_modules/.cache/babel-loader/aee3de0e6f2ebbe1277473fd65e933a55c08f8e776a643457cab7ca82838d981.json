{"ast":null,"code":"import * as base from '@scure/base';\nexport const EMPTY = new Uint8Array();\nexport const NULL = new Uint8Array([0]);\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\nexport function concatBytes(...arrays) {\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nexport const isBytes = b => b instanceof Uint8Array;\nexport class Reader {\n  constructor(data, path = [], fieldPath = []) {\n    this.data = data;\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.pos = 0;\n    this.hasPtr = false;\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  err(msg) {\n    return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n  }\n  absBytes(n) {\n    if (n > this.data.length) throw new Error('absBytes: Unexpected end of buffer');\n    return this.data.subarray(n);\n  }\n  bytes(n, peek = false) {\n    if (this.bitPos) throw this.err('readBytes: bitPos not empty');\n    if (!Number.isFinite(n)) throw this.err(`readBytes: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const slice = this.data.subarray(this.pos, this.pos + n);\n    if (!peek) this.pos += n;\n    return slice;\n  }\n  byte(peek = false) {\n    if (this.bitPos) throw this.err('readByte: bitPos not empty');\n    return this.data[peek ? this.pos : this.pos++];\n  }\n  get leftBytes() {\n    return this.data.length - this.pos;\n  }\n  isEnd() {\n    return this.pos >= this.data.length && !this.bitPos;\n  }\n  length(len) {\n    let byteLen;\n    if (isCoder(len)) byteLen = Number(len.decodeStream(this));else if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n    if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n    if (typeof byteLen !== 'number') throw this.err(`Wrong length: ${byteLen}`);\n    return byteLen;\n  }\n  bits(bits) {\n    if (bits > 32) throw this.err('BitReader: cannot read more than 32 bits in single call');\n    let out = 0;\n    while (bits) {\n      if (!this.bitPos) {\n        this.bitBuf = this.data[this.pos++];\n        this.bitPos = 8;\n      }\n      const take = Math.min(bits, this.bitPos);\n      this.bitPos -= take;\n      out = out << take | this.bitBuf >> this.bitPos & 2 ** take - 1;\n      this.bitBuf &= 2 ** this.bitPos - 1;\n      bits -= take;\n    }\n    return out >>> 0;\n  }\n  find(needle, pos = this.pos) {\n    if (!isBytes(needle)) throw this.err(`find: needle is not bytes! ${needle}`);\n    if (this.bitPos) throw this.err('findByte: bitPos not empty');\n    if (!needle.length) throw this.err(`find: needle is empty`);\n    for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n      if (idx === -1) return;\n      const leftBytes = this.data.length - idx;\n      if (leftBytes < needle.length) return;\n      if (equalBytes(needle, this.data.subarray(idx, idx + needle.length))) return idx;\n    }\n  }\n  finish() {\n    if (this.isEnd() || this.hasPtr) return;\n    throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${base.hex.encode(this.data.slice(this.pos))}`);\n  }\n  fieldPathPush(s) {\n    this.fieldPath.push(s);\n  }\n  fieldPathPop() {\n    this.fieldPath.pop();\n  }\n}\nexport class Writer {\n  constructor(path = [], fieldPath = []) {\n    this.path = path;\n    this.fieldPath = fieldPath;\n    this.buffers = [];\n    this.pos = 0;\n    this.ptrs = [];\n    this.bitBuf = 0;\n    this.bitPos = 0;\n  }\n  err(msg) {\n    return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n  }\n  bytes(b) {\n    if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer');\n    this.buffers.push(b);\n    this.pos += b.length;\n  }\n  byte(b) {\n    if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer');\n    this.buffers.push(new Uint8Array([b]));\n    this.pos++;\n  }\n  get buffer() {\n    if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer');\n    let buf = concatBytes(...this.buffers);\n    for (let ptr of this.ptrs) {\n      const pos = buf.length;\n      buf = concatBytes(buf, ptr.buffer);\n      const val = ptr.ptr.encode(pos);\n      for (let i = 0; i < val.length; i++) buf[ptr.pos + i] = val[i];\n    }\n    return buf;\n  }\n  length(len, value) {\n    if (len === null) return;\n    if (isCoder(len)) return len.encodeStream(this, value);\n    let byteLen;\n    if (typeof len === 'number') byteLen = len;else if (typeof len === 'string') byteLen = getPath(this.path, len.split('/'));\n    if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n    if (byteLen === undefined || byteLen !== value) throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n  }\n  bits(value, bits) {\n    if (bits > 32) throw this.err('writeBits: cannot write more than 32 bits in single call');\n    if (value >= 2 ** bits) throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n    while (bits) {\n      const take = Math.min(bits, 8 - this.bitPos);\n      this.bitBuf = this.bitBuf << take | value >> bits - take;\n      this.bitPos += take;\n      bits -= take;\n      value &= 2 ** bits - 1;\n      if (this.bitPos === 8) {\n        this.bitPos = 0;\n        this.buffers.push(new Uint8Array([this.bitBuf]));\n        this.pos++;\n      }\n    }\n  }\n  fieldPathPush(s) {\n    this.fieldPath.push(s);\n  }\n  fieldPathPop() {\n    this.fieldPath.pop();\n  }\n}\nconst swap = b => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n  if (signed) {\n    const signBit = 2n ** (bits - 1n);\n    if (value < -signBit || value >= signBit) throw p.err('sInt: value out of bounds');\n  } else {\n    if (0n > value || value >= 2n ** bits) throw p.err('uInt: value out of bounds');\n  }\n}\nexport function wrap(inner) {\n  return {\n    ...inner,\n    encode: value => {\n      const w = new Writer();\n      inner.encodeStream(w, value);\n      return w.buffer;\n    },\n    decode: data => {\n      const r = new Reader(data);\n      const res = inner.decodeStream(r);\n      r.finish();\n      return res;\n    }\n  };\n}\nfunction getPath(objPath, path) {\n  objPath = Array.from(objPath);\n  let i = 0;\n  for (; i < path.length; i++) {\n    if (path[i] === '..') objPath.pop();else break;\n  }\n  let cur = objPath.pop();\n  for (; i < path.length; i++) {\n    if (!cur || cur[path[i]] === undefined) return undefined;\n    cur = cur[path[i]];\n  }\n  return cur;\n}\nexport function isCoder(elm) {\n  return typeof elm.encode === 'function' && typeof elm.encodeStream === 'function' && typeof elm.decode === 'function' && typeof elm.decodeStream === 'function';\n}\nfunction dict() {\n  return {\n    encode: from => {\n      const to = {};\n      for (const [name, value] of from) {\n        if (to[name] !== undefined) throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n        to[name] = value;\n      }\n      return to;\n    },\n    decode: to => Object.entries(to)\n  };\n}\nconst number = {\n  encode: from => {\n    if (from > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n    return Number(from);\n  },\n  decode: to => BigInt(to)\n};\nfunction tsEnum(e) {\n  return {\n    encode: from => e[from],\n    decode: to => e[to]\n  };\n}\nfunction decimal(precision) {\n  const decimalMask = 10n ** BigInt(precision);\n  return {\n    encode: from => {\n      let s = (from < 0n ? -from : from).toString(10);\n      let sep = s.length - precision;\n      if (sep < 0) {\n        s = s.padStart(s.length - sep, '0');\n        sep = 0;\n      }\n      let i = s.length - 1;\n      for (; i >= sep && s[i] === '0'; i--);\n      let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n      if (!int) int = '0';\n      if (from < 0n) int = '-' + int;\n      if (!frac) return int;\n      return `${int}.${frac}`;\n    },\n    decode: to => {\n      let neg = false;\n      if (to.startsWith('-')) {\n        neg = true;\n        to = to.slice(1);\n      }\n      let sep = to.indexOf('.');\n      sep = sep === -1 ? to.length : sep;\n      const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n      const int = BigInt(intS) * decimalMask;\n      const fracLen = Math.min(fracS.length, precision);\n      const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n      const value = int + frac;\n      return neg ? -value : value;\n    }\n  };\n}\nfunction match(lst) {\n  return {\n    encode: from => {\n      for (const c of lst) {\n        const elm = c.encode(from);\n        if (elm !== undefined) return elm;\n      }\n      throw new Error(`match/encode: cannot find match in ${from}`);\n    },\n    decode: to => {\n      for (const c of lst) {\n        const elm = c.decode(to);\n        if (elm !== undefined) return elm;\n      }\n      throw new Error(`match/decode: cannot find match in ${to}`);\n    }\n  };\n}\nexport const coders = {\n  dict,\n  number,\n  tsEnum,\n  decimal,\n  match\n};\nexport const bits = len => wrap({\n  encodeStream: (w, value) => w.bits(value, len),\n  decodeStream: r => r.bits(len)\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n  size,\n  encodeStream: (w, value) => {\n    if (typeof value !== 'number' && typeof value !== 'bigint') throw w.err(`bigint: invalid value: ${value}`);\n    let _value = BigInt(value);\n    const bLen = BigInt(size);\n    checkBounds(w, _value, 8n * bLen, !!signed);\n    const signBit = 2n ** (8n * bLen - 1n);\n    if (signed && _value < 0) _value = _value | signBit;\n    let b = [];\n    for (let i = 0; i < size; i++) {\n      b.push(Number(_value & 255n));\n      _value >>= 8n;\n    }\n    let res = new Uint8Array(b).reverse();\n    w.bytes(le ? res.reverse() : res);\n  },\n  decodeStream: r => {\n    const bLen = BigInt(size);\n    let value = r.bytes(size);\n    if (le) value = swap(value);\n    const b = swap(value);\n    const signBit = 2n ** (8n * bLen - 1n);\n    let res = 0n;\n    for (let i = 0; i < b.length; i++) res |= BigInt(b[i]) << 8n * BigInt(i);\n    if (signed && res & signBit) res = (res ^ signBit) - signBit;\n    checkBounds(r, res, 8n * bLen, !!signed);\n    return res;\n  }\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n  if (size > 6) throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n  return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n  size: 1,\n  encodeStream: (w, value) => w.byte(value ? 1 : 0),\n  decodeStream: r => {\n    const value = r.byte();\n    if (value !== 0 && value !== 1) throw r.err(`bool: invalid value ${value}`);\n    return value === 1;\n  }\n});\nexport const bytes = (len, le = false) => wrap({\n  size: typeof len === 'number' ? len : undefined,\n  encodeStream: (w, value) => {\n    if (!isBytes(value)) throw w.err(`bytes: invalid value ${value}`);\n    if (!isBytes(len)) w.length(len, value.length);\n    w.bytes(le ? swap(value) : value);\n    if (isBytes(len)) w.bytes(len);\n  },\n  decodeStream: r => {\n    let bytes;\n    if (isBytes(len)) {\n      const tPos = r.find(len);\n      if (!tPos) throw r.err(`bytes: cannot find terminator`);\n      bytes = r.bytes(tPos - r.pos);\n      r.bytes(len.length);\n    } else bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n    return le ? swap(bytes) : bytes;\n  }\n});\nexport const string = (len, le = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, base.utf8.decode(value)),\n    decodeStream: r => base.utf8.encode(inner.decodeStream(r))\n  });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      if (withZero && !value.startsWith('0x')) throw new Error('hex(withZero=true).encode input should start with 0x');\n      const bytes = base.hex.decode(withZero ? value.slice(2) : value);\n      return inner.encodeStream(w, bytes);\n    },\n    decodeStream: r => (withZero ? '0x' : '') + base.hex.encode(inner.decodeStream(r))\n  });\n};\nexport function apply(inner, b) {\n  if (!isCoder(inner)) throw new Error(`apply: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      let innerValue;\n      try {\n        innerValue = b.decode(value);\n      } catch (e) {\n        throw w.err('' + e);\n      }\n      return inner.encodeStream(w, innerValue);\n    },\n    decodeStream: r => {\n      const innerValue = inner.decodeStream(r);\n      try {\n        return b.encode(innerValue);\n      } catch (e) {\n        throw r.err('' + e);\n      }\n    }\n  });\n}\nexport function validate(inner, fn) {\n  if (!isCoder(inner)) throw new Error(`validate: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n    decodeStream: r => fn(inner.decodeStream(r))\n  });\n}\nexport function lazy(fn) {\n  return wrap({\n    encodeStream: (w, value) => fn().encodeStream(w, value),\n    decodeStream: r => fn().decodeStream(r)\n  });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n  const inner = bytes(len, le);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, base.bytes(fmt, value)),\n    decodeStream: r => base.str(fmt, inner.decodeStream(r))\n  });\n};\nexport const flag = (flagValue, xor = false) => wrap({\n  size: flagValue.length,\n  encodeStream: (w, value) => {\n    if (!!value !== xor) w.bytes(flagValue);\n  },\n  decodeStream: r => {\n    let hasFlag = r.leftBytes >= flagValue.length;\n    if (hasFlag) {\n      hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n      if (hasFlag) r.bytes(flagValue.length);\n    }\n    return hasFlag !== xor;\n  }\n});\nexport function flagged(path, inner, def) {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  return wrap({\n    encodeStream: (w, value) => {\n      if (typeof path === 'string') {\n        if (getPath(w.path, path.split('/'))) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      } else {\n        path.encodeStream(w, !!value);\n        if (!!value) inner.encodeStream(w, value);else if (def) inner.encodeStream(w, def);\n      }\n    },\n    decodeStream: r => {\n      let hasFlag = false;\n      if (typeof path === 'string') hasFlag = getPath(r.path, path.split('/'));else hasFlag = path.decodeStream(r);\n      if (hasFlag) return inner.decodeStream(r);else if (def) inner.decodeStream(r);\n    }\n  });\n}\nexport function optional(flag, inner, def) {\n  if (!isCoder(flag) || !isCoder(inner)) throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n  return wrap({\n    size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n    encodeStream: (w, value) => {\n      flag.encodeStream(w, !!value);\n      if (value) inner.encodeStream(w, value);else if (def !== undefined) inner.encodeStream(w, def);\n    },\n    decodeStream: r => {\n      if (flag.decodeStream(r)) return inner.decodeStream(r);else if (def !== undefined) inner.decodeStream(r);\n    }\n  });\n}\nexport function magic(inner, constant, check = true) {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, constant),\n    decodeStream: r => {\n      const value = inner.decodeStream(r);\n      if (check && typeof value !== 'object' && value !== constant || isBytes(constant) && !equalBytes(constant, value)) {\n        throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n      }\n      return;\n    }\n  });\n}\nexport const magicBytes = constant => {\n  const c = typeof constant === 'string' ? base.utf8.decode(constant) : constant;\n  return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n  return wrap({\n    encodeStream: (w, value) => {\n      if (value !== c) throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n    },\n    decodeStream: r => c\n  });\n}\nfunction sizeof(fields) {\n  let size = 0;\n  for (let f of fields) {\n    if (!f.size) return;\n    size += f.size;\n  }\n  return size;\n}\nexport function struct(fields) {\n  if (Array.isArray(fields)) throw new Error('Packed.Struct: got array instead of object');\n  return wrap({\n    size: sizeof(Object.values(fields)),\n    encodeStream: (w, value) => {\n      if (typeof value !== 'object' || value === null) throw w.err(`struct: invalid value ${value}`);\n      w.path.push(value);\n      for (let name in fields) {\n        w.fieldPathPush(name);\n        let field = fields[name];\n        field.encodeStream(w, value[name]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: r => {\n      let res = {};\n      r.path.push(res);\n      for (let name in fields) {\n        r.fieldPathPush(name);\n        res[name] = fields[name].decodeStream(r);\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function tuple(fields) {\n  if (!Array.isArray(fields)) throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n  return wrap({\n    size: sizeof(fields),\n    encodeStream: (w, value) => {\n      if (!Array.isArray(value)) throw w.err(`tuple: invalid value ${value}`);\n      w.path.push(value);\n      for (let i = 0; i < fields.length; i++) {\n        w.fieldPathPush('' + i);\n        fields[i].encodeStream(w, value[i]);\n        w.fieldPathPop();\n      }\n      w.path.pop();\n    },\n    decodeStream: r => {\n      let res = [];\n      r.path.push(res);\n      for (let i = 0; i < fields.length; i++) {\n        r.fieldPathPush('' + i);\n        res.push(fields[i].decodeStream(r));\n        r.fieldPathPop();\n      }\n      r.path.pop();\n      return res;\n    }\n  });\n}\nexport function prefix(len, inner) {\n  if (!isCoder(inner)) throw new Error(`prefix: invalid inner value ${inner}`);\n  if (isBytes(len)) throw new Error(`prefix: len cannot be Uint8Array`);\n  const b = bytes(len);\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n      const wChild = new Writer(w.path, w.fieldPath);\n      inner.encodeStream(wChild, value);\n      b.encodeStream(w, wChild.buffer);\n    },\n    decodeStream: r => {\n      const data = b.decodeStream(r);\n      return inner.decodeStream(new Reader(data, r.path, r.fieldPath));\n    }\n  });\n}\nexport function array(len, inner) {\n  if (!isCoder(inner)) throw new Error(`array: invalid inner value ${inner}`);\n  return wrap({\n    size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n    encodeStream: (w, value) => {\n      if (!Array.isArray(value)) throw w.err(`array: invalid value ${value}`);\n      if (!isBytes(len)) w.length(len, value.length);\n      w.path.push(value);\n      for (let i = 0; i < value.length; i++) {\n        w.fieldPathPush('' + i);\n        const elm = value[i];\n        const startPos = w.pos;\n        inner.encodeStream(w, elm);\n        if (isBytes(len)) {\n          if (len.length > w.pos - startPos) continue;\n          const data = w.buffer.subarray(startPos, w.pos);\n          if (equalBytes(data.subarray(0, len.length), len)) throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n        }\n        w.fieldPathPop();\n      }\n      w.path.pop();\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: r => {\n      let res = [];\n      if (len === null) {\n        let i = 0;\n        r.path.push(res);\n        while (!r.isEnd()) {\n          r.fieldPathPush('' + i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n          if (inner.size && r.leftBytes < inner.size) break;\n        }\n        r.path.pop();\n      } else if (isBytes(len)) {\n        let i = 0;\n        r.path.push(res);\n        while (true) {\n          if (equalBytes(r.bytes(len.length, true), len)) {\n            r.bytes(len.length);\n            break;\n          }\n          r.fieldPathPush('' + i++);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      } else {\n        r.fieldPathPush('arrayLen');\n        const length = r.length(len);\n        r.fieldPathPop();\n        r.path.push(res);\n        for (let i = 0; i < length; i++) {\n          r.fieldPathPush('' + i);\n          res.push(inner.decodeStream(r));\n          r.fieldPathPop();\n        }\n        r.path.pop();\n      }\n      return res;\n    }\n  });\n}\nexport function map(inner, variants) {\n  if (!isCoder(inner)) throw new Error(`map: invalid inner value ${inner}`);\n  const variantNames = new Map();\n  for (const k in variants) variantNames.set(variants[k], k);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => {\n      if (typeof value !== 'string') throw w.err(`map: invalid value ${value}`);\n      if (!(value in variants)) throw w.err(`Map: unknown variant: ${value}`);\n      inner.encodeStream(w, variants[value]);\n    },\n    decodeStream: r => {\n      const variant = inner.decodeStream(r);\n      const name = variantNames.get(variant);\n      if (name === undefined) throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n      return name;\n    }\n  });\n}\nexport function tag(tag, variants) {\n  if (!isCoder(tag)) throw new Error(`tag: invalid tag value ${tag}`);\n  return wrap({\n    size: tag.size,\n    encodeStream: (w, value) => {\n      const {\n        TAG,\n        data\n      } = value;\n      const dataType = variants[TAG];\n      if (!dataType) throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n      tag.encodeStream(w, TAG);\n      dataType.encodeStream(w, data);\n    },\n    decodeStream: r => {\n      const TAG = tag.decodeStream(r);\n      const dataType = variants[TAG];\n      if (!dataType) throw r.err(`Tag: invalid tag ${TAG}`);\n      return {\n        TAG,\n        data: dataType.decodeStream(r)\n      };\n    }\n  });\n}\nexport function mappedTag(tagCoder, variants) {\n  if (!isCoder(tagCoder)) throw new Error(`mappedTag: invalid tag value ${tag}`);\n  const mapValue = {};\n  const tagValue = {};\n  for (const key in variants) {\n    mapValue[key] = variants[key][0];\n    tagValue[key] = variants[key][1];\n  }\n  return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n  return wrap({\n    encodeStream: (w, value) => {\n      if (typeof value !== 'object' || value === null) throw w.err(`bitset: invalid value ${value}`);\n      for (let i = 0; i < names.length; i++) w.bits(+value[names[i]], 1);\n      if (pad && names.length % 8) w.bits(0, 8 - names.length % 8);\n    },\n    decodeStream: r => {\n      let out = {};\n      for (let i = 0; i < names.length; i++) out[names[i]] = !!r.bits(1);\n      if (pad && names.length % 8) r.bits(8 - names.length % 8);\n      return out;\n    }\n  });\n}\nexport const ZeroPad = _ => 0;\nfunction padLength(blockSize, len) {\n  if (len % blockSize === 0) return 0;\n  return blockSize - len % blockSize;\n}\nexport function padLeft(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(`padLeft: invalid inner value ${inner}`);\n  const _padFn = padFn || ZeroPad;\n  if (!inner.size) throw new Error('padLeft with dynamic size argument is impossible');\n  return wrap({\n    size: inner.size + padLength(blockSize, inner.size),\n    encodeStream: (w, value) => {\n      const padBytes = padLength(blockSize, inner.size);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n      inner.encodeStream(w, value);\n    },\n    decodeStream: r => {\n      r.bytes(padLength(blockSize, inner.size));\n      return inner.decodeStream(r);\n    }\n  });\n}\nexport function padRight(blockSize, inner, padFn) {\n  if (!isCoder(inner)) throw new Error(`padRight: invalid inner value ${inner}`);\n  const _padFn = padFn || ZeroPad;\n  return wrap({\n    size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n    encodeStream: (w, value) => {\n      const pos = w.pos;\n      inner.encodeStream(w, value);\n      const padBytes = padLength(blockSize, w.pos - pos);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n    },\n    decodeStream: r => {\n      const start = r.pos;\n      const res = inner.decodeStream(r);\n      r.bytes(padLength(blockSize, r.pos - start));\n      return res;\n    }\n  });\n}\nexport function pointer(ptr, inner, sized = false) {\n  if (!isCoder(ptr)) throw new Error(`pointer: invalid ptr value ${ptr}`);\n  if (!isCoder(inner)) throw new Error(`pointer: invalid inner value ${inner}`);\n  if (!ptr.size) throw new Error('Pointer: unsized ptr');\n  return wrap({\n    size: sized ? ptr.size : undefined,\n    encodeStream: (w, value) => {\n      const start = w.pos;\n      ptr.encodeStream(w, 0);\n      w.ptrs.push({\n        pos: start,\n        ptr,\n        buffer: inner.encode(value)\n      });\n    },\n    decodeStream: r => {\n      const ptrVal = ptr.decodeStream(r);\n      if (ptrVal < r.pos) throw new Error('pointer.decodeStream pointer less than position');\n      r.hasPtr = true;\n      const rChild = new Reader(r.absBytes(ptrVal), r.path, r.fieldPath);\n      return inner.decodeStream(rChild);\n    }\n  });\n}\nexport function base64armor(name, lineLen, inner, checksum) {\n  const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n  const markEnd = `-----END ${name.toUpperCase()}-----`;\n  return {\n    encode(value) {\n      const data = inner.encode(value);\n      const encoded = base.base64.encode(data);\n      let lines = [];\n      for (let i = 0; i < encoded.length; i += lineLen) {\n        const s = encoded.slice(i, i + lineLen);\n        if (s.length) lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n      }\n      let body = lines.join('');\n      if (checksum) body += `=${base.base64.encode(checksum(data))}\\n`;\n      return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n    },\n    decode(s) {\n      let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n      lines = lines.map(l => l.replace('\\r', '').trim());\n      if (checksum && lines[lines.length - 1].startsWith('=')) {\n        const body = base.base64.decode(lines.slice(0, -1).join(''));\n        const cs = lines[lines.length - 1].slice(1);\n        const realCS = base.base64.encode(checksum(body));\n        if (realCS !== cs) throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n        return inner.decode(body);\n      }\n      return inner.decode(base.base64.decode(lines.join('')));\n    }\n  };\n}\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n  if (!isCoder(inner)) throw new Error(`debug: invalid inner value ${inner}`);\n  const log = (name, rw, value) => {\n    console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, {\n      type: typeof value,\n      value\n    });\n    return value;\n  };\n  return wrap({\n    size: inner.size,\n    encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n    decodeStream: r => log('decode', r, inner.decodeStream(r))\n  });\n}","map":{"version":3,"names":["base","EMPTY","Uint8Array","NULL","equalBytes","a","b","length","i","concatBytes","arrays","reduce","arr","result","pad","set","isBytes","Reader","constructor","data","path","fieldPath","pos","hasPtr","bitBuf","bitPos","err","msg","Error","join","absBytes","n","subarray","bytes","peek","Number","isFinite","slice","byte","leftBytes","isEnd","len","byteLen","isCoder","decodeStream","getPath","split","bits","out","take","Math","min","find","needle","idx","indexOf","finish","hex","encode","fieldPathPush","s","push","fieldPathPop","pop","Writer","buffers","ptrs","buffer","buf","ptr","val","value","encodeStream","undefined","swap","from","reverse","checkBounds","p","signed","signBit","wrap","inner","w","decode","r","res","objPath","Array","cur","elm","dict","to","name","Object","entries","number","BigInt","MAX_SAFE_INTEGER","tsEnum","e","decimal","precision","decimalMask","toString","sep","padStart","int","frac","neg","startsWith","intS","fracS","fracLen","match","lst","c","coders","bigint","size","le","_value","bLen","U256LE","U256BE","I256LE","I256BE","U128LE","U128BE","I128LE","I128BE","U64LE","U64BE","I64LE","I64BE","apply","U32LE","U32BE","I32LE","I32BE","U16LE","U16BE","I16LE","I16BE","U8","I8","bool","tPos","string","utf8","cstring","withZero","innerValue","validate","fn","lazy","bytesFormatted","fmt","str","flag","flagValue","xor","hasFlag","flagged","def","optional","magic","constant","check","magicBytes","sizeof","fields","f","struct","isArray","values","field","tuple","prefix","wChild","array","startPos","map","variants","variantNames","Map","k","variant","get","keys","tag","TAG","dataType","mappedTag","tagCoder","mapValue","tagValue","key","bitset","names","ZeroPad","_","padLength","blockSize","padLeft","padFn","_padFn","padBytes","padRight","start","pointer","sized","ptrVal","rChild","base64armor","lineLen","checksum","markBegin","toUpperCase","markEnd","encoded","base64","lines","body","replace","trim","l","cs","realCS","nothing","debug","log","rw","console","type"],"sources":["/Volumes/Data/sats-connect-example-main/node_modules/micro-packed/index.js"],"sourcesContent":["import * as base from '@scure/base';\nexport const EMPTY = new Uint8Array();\nexport const NULL = new Uint8Array([0]);\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\nexport function concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport const isBytes = (b) => b instanceof Uint8Array;\nexport class Reader {\n    constructor(data, path = [], fieldPath = []) {\n        this.data = data;\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.pos = 0;\n        this.hasPtr = false;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('absBytes: Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.pos += n;\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        return this.data[peek ? this.pos : this.pos++];\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    length(len) {\n        let byteLen;\n        if (isCoder(len))\n            byteLen = Number(len.decodeStream(this));\n        else if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (typeof byteLen !== 'number')\n            throw this.err(`Wrong length: ${byteLen}`);\n        return byteLen;\n    }\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.data[this.pos++];\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n    }\n    finish() {\n        if (this.isEnd() || this.hasPtr)\n            return;\n        throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${base.hex.encode(this.data.slice(this.pos))}`);\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nexport class Writer {\n    constructor(path = [], fieldPath = []) {\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.buffers = [];\n        this.pos = 0;\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    bytes(b) {\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    get buffer() {\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        let buf = concatBytes(...this.buffers);\n        for (let ptr of this.ptrs) {\n            const pos = buf.length;\n            buf = concatBytes(buf, ptr.buffer);\n            const val = ptr.ptr.encode(pos);\n            for (let i = 0; i < val.length; i++)\n                buf[ptr.pos + i] = val[i];\n        }\n        return buf;\n    }\n    length(len, value) {\n        if (len === null)\n            return;\n        if (isCoder(len))\n            return len.encodeStream(this, value);\n        let byteLen;\n        if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (byteLen === undefined || byteLen !== value)\n            throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nconst swap = (b) => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n    if (signed) {\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw p.err('sInt: value out of bounds');\n    }\n    else {\n        if (0n > value || value >= 2n ** bits)\n            throw p.err('uInt: value out of bounds');\n    }\n}\nexport function wrap(inner) {\n    return {\n        ...inner,\n        encode: (value) => {\n            const w = new Writer();\n            inner.encodeStream(w, value);\n            return w.buffer;\n        },\n        decode: (data) => {\n            const r = new Reader(data);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\nfunction getPath(objPath, path) {\n    objPath = Array.from(objPath);\n    let i = 0;\n    for (; i < path.length; i++) {\n        if (path[i] === '..')\n            objPath.pop();\n        else\n            break;\n    }\n    let cur = objPath.pop();\n    for (; i < path.length; i++) {\n        if (!cur || cur[path[i]] === undefined)\n            return undefined;\n        cur = cur[path[i]];\n    }\n    return cur;\n}\nexport function isCoder(elm) {\n    return (typeof elm.encode === 'function' &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decode === 'function' &&\n        typeof elm.decodeStream === 'function');\n}\nfunction dict() {\n    return {\n        encode: (from) => {\n            const to = {};\n            for (const [name, value] of from) {\n                if (to[name] !== undefined)\n                    throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => Object.entries(to),\n    };\n}\nconst number = {\n    encode: (from) => {\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => BigInt(to),\n};\nfunction tsEnum(e) {\n    return {\n        encode: (from) => e[from],\n        decode: (to) => e[to],\n    };\n}\nfunction decimal(precision) {\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n            const int = BigInt(intS) * decimalMask;\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\nfunction match(lst) {\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\nexport const coders = { dict, number, tsEnum, decimal, match };\nexport const bits = (len) => wrap({\n    encodeStream: (w, value) => w.bits(value, len),\n    decodeStream: (r) => r.bits(len),\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n    size,\n    encodeStream: (w, value) => {\n        if (typeof value !== 'number' && typeof value !== 'bigint')\n            throw w.err(`bigint: invalid value: ${value}`);\n        let _value = BigInt(value);\n        const bLen = BigInt(size);\n        checkBounds(w, _value, 8n * bLen, !!signed);\n        const signBit = 2n ** (8n * bLen - 1n);\n        if (signed && _value < 0)\n            _value = _value | signBit;\n        let b = [];\n        for (let i = 0; i < size; i++) {\n            b.push(Number(_value & 255n));\n            _value >>= 8n;\n        }\n        let res = new Uint8Array(b).reverse();\n        w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r) => {\n        const bLen = BigInt(size);\n        let value = r.bytes(size);\n        if (le)\n            value = swap(value);\n        const b = swap(value);\n        const signBit = 2n ** (8n * bLen - 1n);\n        let res = 0n;\n        for (let i = 0; i < b.length; i++)\n            res |= BigInt(b[i]) << (8n * BigInt(i));\n        if (signed && res & signBit)\n            res = (res ^ signBit) - signBit;\n        checkBounds(r, res, 8n * bLen, !!signed);\n        return res;\n    },\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n    return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n});\nexport const bytes = (len, le = false) => wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n        if (!isBytes(value))\n            throw w.err(`bytes: invalid value ${value}`);\n        if (!isBytes(len))\n            w.length(len, value.length);\n        w.bytes(le ? swap(value) : value);\n        if (isBytes(len))\n            w.bytes(len);\n    },\n    decodeStream: (r) => {\n        let bytes;\n        if (isBytes(len)) {\n            const tPos = r.find(len);\n            if (!tPos)\n                throw r.err(`bytes: cannot find terminator`);\n            bytes = r.bytes(tPos - r.pos);\n            r.bytes(len.length);\n        }\n        else\n            bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n        return le ? swap(bytes) : bytes;\n    },\n});\nexport const string = (len, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base.utf8.decode(value)),\n        decodeStream: (r) => base.utf8.encode(inner.decodeStream(r)),\n    });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (withZero && !value.startsWith('0x'))\n                throw new Error('hex(withZero=true).encode input should start with 0x');\n            const bytes = base.hex.decode(withZero ? value.slice(2) : value);\n            return inner.encodeStream(w, bytes);\n        },\n        decodeStream: (r) => (withZero ? '0x' : '') + base.hex.encode(inner.decodeStream(r)),\n    });\n};\nexport function apply(inner, b) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = b.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return b.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n        decodeStream: (r) => fn(inner.decodeStream(r)),\n    });\n}\nexport function lazy(fn) {\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base.bytes(fmt, value)),\n        decodeStream: (r) => base.str(fmt, inner.decodeStream(r)),\n    });\n};\nexport const flag = (flagValue, xor = false) => wrap({\n    size: flagValue.length,\n    encodeStream: (w, value) => {\n        if (!!value !== xor)\n            w.bytes(flagValue);\n    },\n    decodeStream: (r) => {\n        let hasFlag = r.leftBytes >= flagValue.length;\n        if (hasFlag) {\n            hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n            if (hasFlag)\n                r.bytes(flagValue.length);\n        }\n        return hasFlag !== xor;\n    },\n});\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (getPath(w.path, path.split('/')))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = getPath(r.path, path.split('/'));\n            else\n                hasFlag = path.decodeStream(r);\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n        },\n    });\n}\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n        },\n    });\n}\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n    });\n}\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? base.utf8.decode(constant) : constant;\n    return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (let f of fields) {\n        if (!f.size)\n            return;\n        size += f.size;\n    }\n    return size;\n}\nexport function struct(fields) {\n    if (Array.isArray(fields))\n        throw new Error('Packed.Struct: got array instead of object');\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`struct: invalid value ${value}`);\n            w.path.push(value);\n            for (let name in fields) {\n                w.fieldPathPush(name);\n                let field = fields[name];\n                field.encodeStream(w, value[name]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = {};\n            r.path.push(res);\n            for (let name in fields) {\n                r.fieldPathPush(name);\n                res[name] = fields[name].decodeStream(r);\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.path.push(value);\n            for (let i = 0; i < fields.length; i++) {\n                w.fieldPathPush('' + i);\n                fields[i].encodeStream(w, value[i]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = [];\n            r.path.push(res);\n            for (let i = 0; i < fields.length; i++) {\n                r.fieldPathPush('' + i);\n                res.push(fields[i].decodeStream(r));\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    if (isBytes(len))\n        throw new Error(`prefix: len cannot be Uint8Array`);\n    const b = bytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            const wChild = new Writer(w.path, w.fieldPath);\n            inner.encodeStream(wChild, value);\n            b.encodeStream(w, wChild.buffer);\n        },\n        decodeStream: (r) => {\n            const data = b.decodeStream(r);\n            return inner.decodeStream(new Reader(data, r.path, r.fieldPath));\n        },\n    });\n}\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`array: invalid value ${value}`);\n            if (!isBytes(len))\n                w.length(len, value.length);\n            w.path.push(value);\n            for (let i = 0; i < value.length; i++) {\n                w.fieldPathPush('' + i);\n                const elm = value[i];\n                const startPos = w.pos;\n                inner.encodeStream(w, elm);\n                if (isBytes(len)) {\n                    if (len.length > w.pos - startPos)\n                        continue;\n                    const data = w.buffer.subarray(startPos, w.pos);\n                    if (equalBytes(data.subarray(0, len.length), len))\n                        throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                }\n                w.fieldPathPop();\n            }\n            w.path.pop();\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let res = [];\n            if (len === null) {\n                let i = 0;\n                r.path.push(res);\n                while (!r.isEnd()) {\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                    if (inner.size && r.leftBytes < inner.size)\n                        break;\n                }\n                r.path.pop();\n            }\n            else if (isBytes(len)) {\n                let i = 0;\n                r.path.push(res);\n                while (true) {\n                    if (equalBytes(r.bytes(len.length, true), len)) {\n                        r.bytes(len.length);\n                        break;\n                    }\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            else {\n                r.fieldPathPush('arrayLen');\n                const length = r.length(len);\n                r.fieldPathPop();\n                r.path.push(res);\n                for (let i = 0; i < length; i++) {\n                    r.fieldPathPush('' + i);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            return res;\n        },\n    });\n}\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (typeof value !== 'string')\n                throw w.err(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw w.err(`Map: unknown variant: ${value}`);\n            inner.encodeStream(w, variants[value]);\n        },\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n    });\n}\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n    });\n}\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        mapValue[key] = variants[key][0];\n        tagValue[key] = variants[key][1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`bitset: invalid value ${value}`);\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            let out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n    });\n}\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft with dynamic size argument is impossible');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const pos = w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (!ptr.size)\n        throw new Error('Pointer: unsized ptr');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            const start = w.pos;\n            ptr.encodeStream(w, 0);\n            w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            if (ptrVal < r.pos)\n                throw new Error('pointer.decodeStream pointer less than position');\n            r.hasPtr = true;\n            const rChild = new Reader(r.absBytes(ptrVal), r.path, r.fieldPath);\n            return inner.decodeStream(rChild);\n        },\n    });\n}\nexport function base64armor(name, lineLen, inner, checksum) {\n    const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n    const markEnd = `-----END ${name.toUpperCase()}-----`;\n    return {\n        encode(value) {\n            const data = inner.encode(value);\n            const encoded = base.base64.encode(data);\n            let lines = [];\n            for (let i = 0; i < encoded.length; i += lineLen) {\n                const s = encoded.slice(i, i + lineLen);\n                if (s.length)\n                    lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n            }\n            let body = lines.join('');\n            if (checksum)\n                body += `=${base.base64.encode(checksum(data))}\\n`;\n            return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n        },\n        decode(s) {\n            let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n            lines = lines.map((l) => l.replace('\\r', '').trim());\n            if (checksum && lines[lines.length - 1].startsWith('=')) {\n                const body = base.base64.decode(lines.slice(0, -1).join(''));\n                const cs = lines[lines.length - 1].slice(1);\n                const realCS = base.base64.encode(checksum(body));\n                if (realCS !== cs)\n                    throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n                return inner.decode(body);\n            }\n            return inner.decode(base.base64.decode(lines.join('')));\n        },\n    };\n}\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n    if (!isCoder(inner))\n        throw new Error(`debug: invalid inner value ${inner}`);\n    const log = (name, rw, value) => {\n        console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, { type: typeof value, value });\n        return value;\n    };\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n        decodeStream: (r) => log('decode', r, inner.decodeStream(r)),\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}